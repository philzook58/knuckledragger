

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>kdrag.utils &mdash; knuckledragger 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="kdrag.utils.all_values" href="kdrag.utils.all_values.html" />
    <link rel="prev" title="kdrag.theories.sexp.parse" href="kdrag.theories.sexp.parse.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            knuckledragger
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="kdrag.html">kdrag</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Calc"><code class="docutils literal notranslate"><span class="pre">Calc</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.FreshVar"><code class="docutils literal notranslate"><span class="pre">FreshVar()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.FreshVars"><code class="docutils literal notranslate"><span class="pre">FreshVars()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Inductive"><code class="docutils literal notranslate"><span class="pre">Inductive()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Lemma"><code class="docutils literal notranslate"><span class="pre">Lemma()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.NewType"><code class="docutils literal notranslate"><span class="pre">NewType()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.PTheorem"><code class="docutils literal notranslate"><span class="pre">PTheorem()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Proof"><code class="docutils literal notranslate"><span class="pre">Proof</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.QExists"><code class="docutils literal notranslate"><span class="pre">QExists()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.QForAll"><code class="docutils literal notranslate"><span class="pre">QForAll()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.QImplies"><code class="docutils literal notranslate"><span class="pre">QImplies()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Struct"><code class="docutils literal notranslate"><span class="pre">Struct()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.Theorem"><code class="docutils literal notranslate"><span class="pre">Theorem()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.axiom"><code class="docutils literal notranslate"><span class="pre">axiom()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.cond"><code class="docutils literal notranslate"><span class="pre">cond()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.define"><code class="docutils literal notranslate"><span class="pre">define()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.prove"><code class="docutils literal notranslate"><span class="pre">prove()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.search"><code class="docutils literal notranslate"><span class="pre">search()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.html#kdrag.simp"><code class="docutils literal notranslate"><span class="pre">simp()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.all.html">kdrag.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.config.html">kdrag.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.contrib.html">kdrag.contrib</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.datatype.html">kdrag.datatype</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.hypothesis.html">kdrag.hypothesis</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.kernel.html">kdrag.kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.modal.html">kdrag.modal</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.notation.html">kdrag.notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.parsers.html">kdrag.parsers</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.printers.html">kdrag.printers</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.property.html">kdrag.property</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.reflect.html">kdrag.reflect</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.rewrite.html">kdrag.rewrite</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.smt.html">kdrag.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.solvers.html">kdrag.solvers</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.tactics.html">kdrag.tactics</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.tele.html">kdrag.tele</a></li>
<li class="toctree-l2"><a class="reference internal" href="kdrag.theories.html">kdrag.theories</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">kdrag.utils</a><ul>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.all_values.html">kdrag.utils.all_values</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.alpha_eq.html">kdrag.utils.alpha_eq</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.alpha_norm.html">kdrag.utils.alpha_norm</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.antipattern.html">kdrag.utils.antipattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.ast_size_sexpr.html">kdrag.utils.ast_size_sexpr</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.bysect.html">kdrag.utils.bysect</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.consts.html">kdrag.utils.consts</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.decls.html">kdrag.utils.decls</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.defined_decls.html">kdrag.utils.defined_decls</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.find_calls.html">kdrag.utils.find_calls</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.free_in.html">kdrag.utils.free_in</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.free_vars.html">kdrag.utils.free_vars</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.generate.html">kdrag.utils.generate</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.is_strict_subterm.html">kdrag.utils.is_strict_subterm</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.is_subterm.html">kdrag.utils.is_subterm</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.is_value.html">kdrag.utils.is_value</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.lemma_db.html">kdrag.utils.lemma_db</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.occurs.html">kdrag.utils.occurs</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.open_binder.html">kdrag.utils.open_binder</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.open_binder_unhygienic.html">kdrag.utils.open_binder_unhygienic</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.pathmap.html">kdrag.utils.pathmap</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.pmatch.html">kdrag.utils.pmatch</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.pmatch_fo.html">kdrag.utils.pmatch_fo</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.pmatch_rec.html">kdrag.utils.pmatch_rec</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.pmatch_rec_ctx.html">kdrag.utils.pmatch_rec_ctx</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.prompt.html">kdrag.utils.prompt</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.propagate.html">kdrag.utils.propagate</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.propagate_eqs.html">kdrag.utils.propagate_eqs</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.prune.html">kdrag.utils.prune</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.quant_kind_eq.html">kdrag.utils.quant_kind_eq</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.sanity_check_consistency.html">kdrag.utils.sanity_check_consistency</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.search.html">kdrag.utils.search</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.search_decl.html">kdrag.utils.search_decl</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.search_expr.html">kdrag.utils.search_expr</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.sorts.html">kdrag.utils.sorts</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.subterms.html">kdrag.utils.subterms</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.unify.html">kdrag.utils.unify</a></li>
<li class="toctree-l3"><a class="reference internal" href="kdrag.utils.unify_db.html">kdrag.utils.unify_db</a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.DeclHole"><code class="docutils literal notranslate"><span class="pre">DeclHole</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.f"><code class="docutils literal notranslate"><span class="pre">DeclHole.f</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.has_left"><code class="docutils literal notranslate"><span class="pre">DeclHole.has_left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.has_right"><code class="docutils literal notranslate"><span class="pre">DeclHole.has_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.left"><code class="docutils literal notranslate"><span class="pre">DeclHole.left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.right"><code class="docutils literal notranslate"><span class="pre">DeclHole.right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.DeclHole.wrap"><code class="docutils literal notranslate"><span class="pre">DeclHole.wrap()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.ExistsHole"><code class="docutils literal notranslate"><span class="pre">ExistsHole</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExistsHole.has_right"><code class="docutils literal notranslate"><span class="pre">ExistsHole.has_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExistsHole.orig_vs"><code class="docutils literal notranslate"><span class="pre">ExistsHole.orig_vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExistsHole.vs"><code class="docutils literal notranslate"><span class="pre">ExistsHole.vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExistsHole.wrap"><code class="docutils literal notranslate"><span class="pre">ExistsHole.wrap()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.ExprCtx"><code class="docutils literal notranslate"><span class="pre">ExprCtx</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.append"><code class="docutils literal notranslate"><span class="pre">ExprCtx.append()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.arg"><code class="docutils literal notranslate"><span class="pre">ExprCtx.arg()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.children"><code class="docutils literal notranslate"><span class="pre">ExprCtx.children()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.clear"><code class="docutils literal notranslate"><span class="pre">ExprCtx.clear()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.copy"><code class="docutils literal notranslate"><span class="pre">ExprCtx.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.count"><code class="docutils literal notranslate"><span class="pre">ExprCtx.count()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.extend"><code class="docutils literal notranslate"><span class="pre">ExprCtx.extend()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.index"><code class="docutils literal notranslate"><span class="pre">ExprCtx.index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.insert"><code class="docutils literal notranslate"><span class="pre">ExprCtx.insert()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.open_binder"><code class="docutils literal notranslate"><span class="pre">ExprCtx.open_binder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.pop"><code class="docutils literal notranslate"><span class="pre">ExprCtx.pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.remove"><code class="docutils literal notranslate"><span class="pre">ExprCtx.remove()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.reverse"><code class="docutils literal notranslate"><span class="pre">ExprCtx.reverse()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.sort"><code class="docutils literal notranslate"><span class="pre">ExprCtx.sort()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ExprCtx.wrap"><code class="docutils literal notranslate"><span class="pre">ExprCtx.wrap()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.ForAllHole"><code class="docutils literal notranslate"><span class="pre">ForAllHole</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ForAllHole.has_right"><code class="docutils literal notranslate"><span class="pre">ForAllHole.has_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ForAllHole.orig_vs"><code class="docutils literal notranslate"><span class="pre">ForAllHole.orig_vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ForAllHole.vs"><code class="docutils literal notranslate"><span class="pre">ForAllHole.vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.ForAllHole.wrap"><code class="docutils literal notranslate"><span class="pre">ForAllHole.wrap()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.LambdaHole"><code class="docutils literal notranslate"><span class="pre">LambdaHole</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.LambdaHole.has_right"><code class="docutils literal notranslate"><span class="pre">LambdaHole.has_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.LambdaHole.orig_vs"><code class="docutils literal notranslate"><span class="pre">LambdaHole.orig_vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.LambdaHole.vs"><code class="docutils literal notranslate"><span class="pre">LambdaHole.vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.LambdaHole.wrap"><code class="docutils literal notranslate"><span class="pre">LambdaHole.wrap()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.QuantifierHole"><code class="docutils literal notranslate"><span class="pre">QuantifierHole</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.QuantifierHole.has_right"><code class="docutils literal notranslate"><span class="pre">QuantifierHole.has_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.QuantifierHole.orig_vs"><code class="docutils literal notranslate"><span class="pre">QuantifierHole.orig_vs</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.QuantifierHole.vs"><code class="docutils literal notranslate"><span class="pre">QuantifierHole.vs</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.Zipper"><code class="docutils literal notranslate"><span class="pre">Zipper</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.__hash__"><code class="docutils literal notranslate"><span class="pre">Zipper.__hash__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.__next__"><code class="docutils literal notranslate"><span class="pre">Zipper.__next__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.arg"><code class="docutils literal notranslate"><span class="pre">Zipper.arg()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.copy"><code class="docutils literal notranslate"><span class="pre">Zipper.copy()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.ctx"><code class="docutils literal notranslate"><span class="pre">Zipper.ctx</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.from_term"><code class="docutils literal notranslate"><span class="pre">Zipper.from_term()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.left"><code class="docutils literal notranslate"><span class="pre">Zipper.left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.open_binder"><code class="docutils literal notranslate"><span class="pre">Zipper.open_binder()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.pmatch"><code class="docutils literal notranslate"><span class="pre">Zipper.pmatch()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.rebuild"><code class="docutils literal notranslate"><span class="pre">Zipper.rebuild()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.right"><code class="docutils literal notranslate"><span class="pre">Zipper.right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.t"><code class="docutils literal notranslate"><span class="pre">Zipper.t</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#kdrag.utils.Zipper.up"><code class="docutils literal notranslate"><span class="pre">Zipper.up()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.all_values"><code class="docutils literal notranslate"><span class="pre">all_values()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.alpha_eq"><code class="docutils literal notranslate"><span class="pre">alpha_eq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.alpha_norm"><code class="docutils literal notranslate"><span class="pre">alpha_norm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.antipattern"><code class="docutils literal notranslate"><span class="pre">antipattern()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.ast_size_sexpr"><code class="docutils literal notranslate"><span class="pre">ast_size_sexpr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.bysect"><code class="docutils literal notranslate"><span class="pre">bysect()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.consts"><code class="docutils literal notranslate"><span class="pre">consts()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.decls"><code class="docutils literal notranslate"><span class="pre">decls()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.defined_decls"><code class="docutils literal notranslate"><span class="pre">defined_decls()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.find_calls"><code class="docutils literal notranslate"><span class="pre">find_calls()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.free_in"><code class="docutils literal notranslate"><span class="pre">free_in()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.free_vars"><code class="docutils literal notranslate"><span class="pre">free_vars()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.generate"><code class="docutils literal notranslate"><span class="pre">generate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.is_strict_subterm"><code class="docutils literal notranslate"><span class="pre">is_strict_subterm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.is_subterm"><code class="docutils literal notranslate"><span class="pre">is_subterm()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.is_value"><code class="docutils literal notranslate"><span class="pre">is_value()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.lemma_db"><code class="docutils literal notranslate"><span class="pre">lemma_db()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.occurs"><code class="docutils literal notranslate"><span class="pre">occurs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.open_binder"><code class="docutils literal notranslate"><span class="pre">open_binder()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.open_binder_unhygienic"><code class="docutils literal notranslate"><span class="pre">open_binder_unhygienic()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.pathmap"><code class="docutils literal notranslate"><span class="pre">pathmap()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.pmatch"><code class="docutils literal notranslate"><span class="pre">pmatch()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.pmatch_fo"><code class="docutils literal notranslate"><span class="pre">pmatch_fo()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.pmatch_rec"><code class="docutils literal notranslate"><span class="pre">pmatch_rec()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.pmatch_rec_ctx"><code class="docutils literal notranslate"><span class="pre">pmatch_rec_ctx()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.prompt"><code class="docutils literal notranslate"><span class="pre">prompt()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.propagate"><code class="docutils literal notranslate"><span class="pre">propagate()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.propagate_eqs"><code class="docutils literal notranslate"><span class="pre">propagate_eqs()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.prune"><code class="docutils literal notranslate"><span class="pre">prune()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.quant_kind_eq"><code class="docutils literal notranslate"><span class="pre">quant_kind_eq()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.sanity_check_consistency"><code class="docutils literal notranslate"><span class="pre">sanity_check_consistency()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.search"><code class="docutils literal notranslate"><span class="pre">search()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.search_decl"><code class="docutils literal notranslate"><span class="pre">search_decl()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.search_expr"><code class="docutils literal notranslate"><span class="pre">search_expr()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.sorts"><code class="docutils literal notranslate"><span class="pre">sorts()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.subterms"><code class="docutils literal notranslate"><span class="pre">subterms()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.unify"><code class="docutils literal notranslate"><span class="pre">unify()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#kdrag.utils.unify_db"><code class="docutils literal notranslate"><span class="pre">unify_db()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">knuckledragger</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="kdrag.html">kdrag</a></li>
      <li class="breadcrumb-item active">kdrag.utils</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/_autosummary/kdrag.utils.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-kdrag.utils">
<span id="kdrag-utils"></span><h1>kdrag.utils<a class="headerlink" href="#module-kdrag.utils" title="Link to this heading"></a></h1>
<p>Various term manipulation helpers. Pattern matchers, unifiers, rewriters, term orderings, etc.</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.all_values.html#kdrag.utils.all_values" title="kdrag.utils.all_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all_values</span></code></a>(*es)</p></td>
<td><p>Generate all values possible for an expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.alpha_eq.html#kdrag.utils.alpha_eq" title="kdrag.utils.alpha_eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alpha_eq</span></code></a>(t1, t2)</p></td>
<td><p>Alpha equivalent equality.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.alpha_norm.html#kdrag.utils.alpha_norm" title="kdrag.utils.alpha_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alpha_norm</span></code></a>(expr)</p></td>
<td><p>Recursively rename all variables in an expression to canonical names.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.antipattern.html#kdrag.utils.antipattern" title="kdrag.utils.antipattern"><code class="xref py py-obj docutils literal notranslate"><span class="pre">antipattern</span></code></a>(xs)</p></td>
<td><p>Anti pattern matching.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.ast_size_sexpr.html#kdrag.utils.ast_size_sexpr" title="kdrag.utils.ast_size_sexpr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ast_size_sexpr</span></code></a>(t)</p></td>
<td><p>Get an approximate size of an AST node by its s-expression length. This is probably faster than any python layer traversal one can do. Pretty printed ast size will be correlated to expression size, maybe even DAG size, since Z3 inserts <a href="#id1"><span class="problematic" id="id2">`</span></a>let`s to avoid duplication.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.bysect.html#kdrag.utils.bysect" title="kdrag.utils.bysect"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bysect</span></code></a>(thm, by, **kwargs)</p></td>
<td><p>Bisect the <cite>by</cite> list to find a minimal set of premises that prove <cite>thm</cite>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.consts.html#kdrag.utils.consts" title="kdrag.utils.consts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">consts</span></code></a>(t)</p></td>
<td><p>Return all constants in a term.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.decls.html#kdrag.utils.decls" title="kdrag.utils.decls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">decls</span></code></a>(t)</p></td>
<td><p>Return all function declarations in a term.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.defined_decls.html#kdrag.utils.defined_decls" title="kdrag.utils.defined_decls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">defined_decls</span></code></a>(t)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.find_calls.html#kdrag.utils.find_calls" title="kdrag.utils.find_calls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_calls</span></code></a>(decl, t)</p></td>
<td><p>Find subterms that are calls of decl in t.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.free_in.html#kdrag.utils.free_in" title="kdrag.utils.free_in"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_in</span></code></a>(vs, t)</p></td>
<td><p>Returns True if none of the variables in vs exist unbound in t.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.free_vars.html#kdrag.utils.free_vars" title="kdrag.utils.free_vars"><code class="xref py py-obj docutils literal notranslate"><span class="pre">free_vars</span></code></a>(t)</p></td>
<td><p>Return free variables in an expression.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.generate.html#kdrag.utils.generate" title="kdrag.utils.generate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generate</span></code></a>(sort[, pred])</p></td>
<td><p>A generator of values for a sort.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.is_strict_subterm.html#kdrag.utils.is_strict_subterm" title="kdrag.utils.is_strict_subterm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_strict_subterm</span></code></a>(t, t2)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.is_subterm.html#kdrag.utils.is_subterm" title="kdrag.utils.is_subterm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_subterm</span></code></a>(t, t2)</p></td>
<td><p>TODO: Not alpha invariant or going into binders</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.is_value.html#kdrag.utils.is_value" title="kdrag.utils.is_value"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_value</span></code></a>(t)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.lemma_db.html#kdrag.utils.lemma_db" title="kdrag.utils.lemma_db"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lemma_db</span></code></a>()</p></td>
<td><p>Scan all modules for Proof objects and return a dictionary of them.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.occurs.html#kdrag.utils.occurs" title="kdrag.utils.occurs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">occurs</span></code></a>(x, t)</p></td>
<td><p>Does x occur in t?</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.open_binder.html#kdrag.utils.open_binder" title="kdrag.utils.open_binder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_binder</span></code></a>(lam)</p></td>
<td><p>Open a quantifier with fresh variables.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.open_binder_unhygienic.html#kdrag.utils.open_binder_unhygienic" title="kdrag.utils.open_binder_unhygienic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">open_binder_unhygienic</span></code></a>(lam)</p></td>
<td><p>Do not use this.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.pathmap.html#kdrag.utils.pathmap" title="kdrag.utils.pathmap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pathmap</span></code></a>(function, e, path)</p></td>
<td><p>Apply function at position in term &gt;&gt;&gt; x,y,z = smt.Ints(&quot;x y z&quot;) &gt;&gt;&gt; pathmap(lambda t: t + 1, x + y * z, [1,0]) x + (y + 1)*z</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.pmatch.html#kdrag.utils.pmatch" title="kdrag.utils.pmatch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmatch</span></code></a>(vs, pat, t[, subst])</p></td>
<td><p>Pattern match t against pat considering vs as variables.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.pmatch_fo.html#kdrag.utils.pmatch_fo" title="kdrag.utils.pmatch_fo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmatch_fo</span></code></a>(vs, pat, t[, subst])</p></td>
<td><p>First order pattern matching.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.pmatch_rec.html#kdrag.utils.pmatch_rec" title="kdrag.utils.pmatch_rec"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmatch_rec</span></code></a>(vs, pat, t[, into_binder])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.pmatch_rec_ctx.html#kdrag.utils.pmatch_rec_ctx" title="kdrag.utils.pmatch_rec_ctx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pmatch_rec_ctx</span></code></a>(vs, pat, t)</p></td>
<td><p>Pattern match <cite>pat</cite> against subterms of <cite>t</cite>, returning the context, matched term, and substitution if successful.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.prompt.html#kdrag.utils.prompt" title="kdrag.utils.prompt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prompt</span></code></a>(prompt)</p></td>
<td><p>Ask an AI.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.propagate.html#kdrag.utils.propagate" title="kdrag.utils.propagate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagate</span></code></a>(maybes, known)</p></td>
<td><p>Prune the list of maybes to the ones implies by known</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.propagate_eqs.html#kdrag.utils.propagate_eqs" title="kdrag.utils.propagate_eqs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagate_eqs</span></code></a>(terms, known)</p></td>
<td><p>Given a list of terms, propagate equalities among them that are implied by known.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.prune.html#kdrag.utils.prune" title="kdrag.utils.prune"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prune</span></code></a>(thm[, by, timeout])</p></td>
<td><p>Prune the theorems used using unsat core.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.quant_kind_eq.html#kdrag.utils.quant_kind_eq" title="kdrag.utils.quant_kind_eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quant_kind_eq</span></code></a>(t1, t2)</p></td>
<td><p>Check both quantifiers are of the same kind</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.sanity_check_consistency.html#kdrag.utils.sanity_check_consistency" title="kdrag.utils.sanity_check_consistency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sanity_check_consistency</span></code></a>(thms[, timeout])</p></td>
<td><p>Sanity check theorems or proofs for consistency.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.search.html#kdrag.utils.search" title="kdrag.utils.search"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search</span></code></a>(*es[, db])</p></td>
<td><p>Search for function declarations or expressions.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.search_decl.html#kdrag.utils.search_decl" title="kdrag.utils.search_decl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search_decl</span></code></a>(f, db)</p></td>
<td><p>Search for declarations in the proof database that contain function declaration f</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.search_expr.html#kdrag.utils.search_expr" title="kdrag.utils.search_expr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">search_expr</span></code></a>(e, pfs)</p></td>
<td><p>Search for expressions in the proof database that match <cite>e</cite> using pattern matching.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.sorts.html#kdrag.utils.sorts" title="kdrag.utils.sorts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sorts</span></code></a>(t)</p></td>
<td><p>Generate all sorts in a term</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.subterms.html#kdrag.utils.subterms" title="kdrag.utils.subterms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subterms</span></code></a>(t[, into_binder])</p></td>
<td><p>Generate all subterms of a term</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="kdrag.utils.unify.html#kdrag.utils.unify" title="kdrag.utils.unify"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unify</span></code></a>(vs, p1, p2)</p></td>
<td><p>Unification</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="kdrag.utils.unify_db.html#kdrag.utils.unify_db" title="kdrag.utils.unify_db"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unify_db</span></code></a>(p1, p2)</p></td>
<td><p>Unification using de Bruijn indices as variables</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#kdrag.utils.DeclHole" title="kdrag.utils.DeclHole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeclHole</span></code></a>(f, _left, _right)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#kdrag.utils.ExistsHole" title="kdrag.utils.ExistsHole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExistsHole</span></code></a>(vs, orig_vs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExprCtx</span></code></a>([iterable])</p></td>
<td><p>A context of holes for an expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#kdrag.utils.ForAllHole" title="kdrag.utils.ForAllHole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ForAllHole</span></code></a>(vs, orig_vs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#kdrag.utils.LambdaHole" title="kdrag.utils.LambdaHole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LambdaHole</span></code></a>(vs, orig_vs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#kdrag.utils.QuantifierHole" title="kdrag.utils.QuantifierHole"><code class="xref py py-obj docutils literal notranslate"><span class="pre">QuantifierHole</span></code></a>(vs, orig_vs)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Zipper</span></code></a>(ctx, t)</p></td>
<td><p>A zipper for traversing and modifying terms.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">DeclHole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">z3.z3.FuncDeclRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_left</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">z3.z3.ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_right</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">z3.z3.ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.DeclHole" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>FuncDeclRef</em>)</p></li>
<li><p><strong>_left</strong> (<em>tuple</em><em>[</em><em>ExprRef</em><em>, </em><em>...</em><em>]</em>)</p></li>
<li><p><strong>_right</strong> (<em>tuple</em><em>[</em><em>ExprRef</em><em>, </em><em>...</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.f">
<span class="sig-name descname"><span class="pre">f</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">FuncDeclRef</span></em><a class="headerlink" href="#kdrag.utils.DeclHole.f" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.has_left">
<span class="sig-name descname"><span class="pre">has_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.DeclHole.has_left" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.has_right">
<span class="sig-name descname"><span class="pre">has_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.DeclHole.has_right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.left">
<span class="sig-name descname"><span class="pre">left</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.DeclHole" title="kdrag.utils.DeclHole"><span class="pre">DeclHole</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.DeclHole.left" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#kdrag.utils.DeclHole" title="kdrag.utils.DeclHole"><em>DeclHole</em></a>, <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.right">
<span class="sig-name descname"><span class="pre">right</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.DeclHole" title="kdrag.utils.DeclHole"><span class="pre">DeclHole</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.DeclHole.right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#kdrag.utils.DeclHole" title="kdrag.utils.DeclHole"><em>DeclHole</em></a>, <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.DeclHole.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.DeclHole.wrap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>e</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.ExistsHole">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">ExistsHole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig_vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExistsHole" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#kdrag.utils.QuantifierHole" title="kdrag.utils.QuantifierHole"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantifierHole</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>orig_vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExistsHole.has_right">
<span class="sig-name descname"><span class="pre">has_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.ExistsHole.has_right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.ExistsHole.orig_vs">
<span class="sig-name descname"><span class="pre">orig_vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.ExistsHole.orig_vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.ExistsHole.vs">
<span class="sig-name descname"><span class="pre">vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.ExistsHole.vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExistsHole.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.ExistsHole.wrap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>body</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">ExprCtx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">()</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></p>
<p>A context of holes for an expression. Similar to Zipper, but with a nonmutating api</p>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.append" title="Link to this definition"></a></dt>
<dd><p>Append object to the end of the list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.arg">
<span class="sig-name descname"><span class="pre">arg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><span class="pre">ExprCtx</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.ExprCtx.arg" title="Link to this definition"></a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExprCtx</span><span class="p">()</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">([DeclHole(f=*, _left=(x + y,), _right=())], y + z)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>n</strong> (<em>int</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><em>ExprCtx</em></a>, <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.children">
<span class="sig-name descname"><span class="pre">children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><span class="pre">ExprCtx</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.ExprCtx.children" title="Link to this definition"></a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExprCtx</span><span class="p">()</span><span class="o">.</span><span class="n">children</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">[([DeclHole(f=*, _left=(), _right=(y + z,))], x + y), ([DeclHole(f=*, _left=(x + y,), _right=())], y + z)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[tuple[<a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><em>ExprCtx</em></a>, <em>ExprRef</em>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.clear" title="Link to this definition"></a></dt>
<dd><p>Remove all items from list.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><span class="pre">ExprCtx</span></a></span></span><a class="headerlink" href="#kdrag.utils.ExprCtx.copy" title="Link to this definition"></a></dt>
<dd><p>Return a shallow copy of the list.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><em>ExprCtx</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.count" title="Link to this definition"></a></dt>
<dd><p>Return number of occurrences of value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.extend" title="Link to this definition"></a></dt>
<dd><p>Extend list by appending elements from the iterable.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.index">
<span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">9223372036854775807</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.index" title="Link to this definition"></a></dt>
<dd><p>Return first index of value.</p>
<p>Raises ValueError if the value is not present.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.insert" title="Link to this definition"></a></dt>
<dd><p>Insert object before index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.open_binder">
<span class="sig-name descname"><span class="pre">open_binder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">QuantifierRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><span class="pre">ExprCtx</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.ExprCtx.open_binder" title="Link to this definition"></a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ExprCtx</span><span class="p">()</span><span class="o">.</span><span class="n">open_binder</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="go">([LambdaHole(vs=[X!...], orig_vs=[x])], X!... + y)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>QuantifierRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><em>ExprCtx</em></a>, <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.pop" title="Link to this definition"></a></dt>
<dd><p>Remove and return item at index (default last).</p>
<p>Raises IndexError if list is empty or index is out of range.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="positional-only-separator o"><abbr title="Positional-only parameter separator (PEP 570)"><span class="pre">/</span></abbr></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.remove" title="Link to this definition"></a></dt>
<dd><p>Remove first occurrence of value.</p>
<p>Raises ValueError if the value is not present.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.reverse">
<span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.reverse" title="Link to this definition"></a></dt>
<dd><p>Reverse <em>IN PLACE</em>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="keyword-only-separator o"><abbr title="Keyword-only parameters separator (PEP 3102)"><span class="pre">*</span></abbr></span></em>, <em class="sig-param"><span class="n"><span class="pre">key</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ExprCtx.sort" title="Link to this definition"></a></dt>
<dd><p>Sort the list in ascending order and return None.</p>
<p>The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
order of two equal elements is maintained).</p>
<p>If a key function is given, apply it once to each list item and sort them,
ascending or descending, according to their function values.</p>
<p>The reverse flag can be set to sort in descending order.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ExprCtx.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.ExprCtx.wrap" title="Link to this definition"></a></dt>
<dd><p>Wrap a term t in the context
&gt;&gt;&gt; x,y,z = smt.Ints(“x y z”)
&gt;&gt;&gt; t = (x + y) * (y + z)
&gt;&gt;&gt; ctx, t1 = ExprCtx().arg(t, 1)
&gt;&gt;&gt; ctx.wrap(t1)
(x + y)*(y + z)</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.ForAllHole">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">ForAllHole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig_vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.ForAllHole" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#kdrag.utils.QuantifierHole" title="kdrag.utils.QuantifierHole"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantifierHole</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>orig_vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ForAllHole.has_right">
<span class="sig-name descname"><span class="pre">has_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.ForAllHole.has_right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.ForAllHole.orig_vs">
<span class="sig-name descname"><span class="pre">orig_vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.ForAllHole.orig_vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.ForAllHole.vs">
<span class="sig-name descname"><span class="pre">vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.ForAllHole.vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.ForAllHole.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.ForAllHole.wrap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>body</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.LambdaHole">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">LambdaHole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig_vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.LambdaHole" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#kdrag.utils.QuantifierHole" title="kdrag.utils.QuantifierHole"><code class="xref py py-class docutils literal notranslate"><span class="pre">QuantifierHole</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>orig_vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.LambdaHole.has_right">
<span class="sig-name descname"><span class="pre">has_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.LambdaHole.has_right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.LambdaHole.orig_vs">
<span class="sig-name descname"><span class="pre">orig_vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.LambdaHole.orig_vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.LambdaHole.vs">
<span class="sig-name descname"><span class="pre">vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.LambdaHole.vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.LambdaHole.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">body</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.LambdaHole.wrap" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>body</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.QuantifierHole">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">QuantifierHole</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">z3.z3.ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orig_vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">z3.z3.ExprRef</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.QuantifierHole" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>orig_vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.QuantifierHole.has_right">
<span class="sig-name descname"><span class="pre">has_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.QuantifierHole.has_right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.QuantifierHole.orig_vs">
<span class="sig-name descname"><span class="pre">orig_vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.QuantifierHole.orig_vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.QuantifierHole.vs">
<span class="sig-name descname"><span class="pre">vs</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.QuantifierHole.vs" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kdrag.utils.Zipper">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">Zipper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ctx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Hole</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.Zipper" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A zipper for traversing and modifying terms. The Zipper retains a context stack of “holes” and the current term.
<a class="reference external" href="https://en.wikipedia.org/wiki/Zipper_(data_structure">https://en.wikipedia.org/wiki/Zipper_(data_structure</a>)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span> <span class="o">=</span> <span class="n">Zipper</span><span class="o">.</span><span class="n">from_term</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span><span class="o">.</span><span class="n">open_binder</span><span class="p">()</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">left</span><span class="p">()</span><span class="o">.</span><span class="n">arg</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Zipper(ctx=[LambdaHole(vs=[X!..., Y!...], orig_vs=[x, y]), DeclHole(f=*, _left=(), _right=(Y!... + z,)), DeclHole(f=+, _left=(), _right=(Y!...,))], t=X!...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">z1</span><span class="o">.</span><span class="n">up</span><span class="p">()</span><span class="o">.</span><span class="n">up</span><span class="p">()</span><span class="o">.</span><span class="n">up</span><span class="p">()</span>
<span class="go">Zipper(ctx=[], t=Lambda([x, y], (x + y)*(y + z)))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ctx</strong> (<em>list</em><em>[</em><em>Hole</em><em>]</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.__hash__">
<span class="sig-name descname"><span class="pre">__hash__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.Zipper.__hash__" title="Link to this definition"></a></dt>
<dd><p>Warning: If you are hashing Zippers, make sure you are copying them.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.__next__">
<span class="sig-name descname"><span class="pre">__next__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.Zipper.__next__" title="Link to this definition"></a></dt>
<dd><p>All subterms of the term in a pre-order traversal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">Zipper</span><span class="p">([],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">))</span>
<span class="go">[x, y*z, y, z]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.arg">
<span class="sig-name descname"><span class="pre">arg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.arg" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.copy" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.ctx">
<span class="sig-name descname"><span class="pre">ctx</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">Hole</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#kdrag.utils.Zipper.ctx" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.from_term">
<em class="property"><span class="k"><span class="pre">classmethod</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_term</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.from_term" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.left">
<span class="sig-name descname"><span class="pre">left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.left" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.open_binder">
<span class="sig-name descname"><span class="pre">open_binder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.open_binder" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.pmatch">
<span class="sig-name descname"><span class="pre">pmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.Zipper.pmatch" title="Link to this definition"></a></dt>
<dd><p>Pattern match the current term against a pattern with variables vs.
Leaves the zipper in a context state.
This can be used to replace but rebuild using original context</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z a b c&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span> <span class="o">=</span> <span class="n">Zipper</span><span class="p">([],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">y</span><span class="p">],</span> <span class="n">y</span><span class="o">*</span><span class="n">z</span><span class="p">)[</span><span class="n">x</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">subst</span> <span class="o">:=</span> <span class="nb">zip</span><span class="o">.</span><span class="n">pmatch</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="p">))</span>
<span class="go">{b: z, a: Y!...}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">subst</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">zip</span><span class="o">.</span><span class="n">rebuild</span><span class="p">()</span>
<span class="go">x + Lambda(y, 1*y)[x]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>pat</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[<em>ExprRef</em>, <em>ExprRef</em>] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.rebuild">
<span class="sig-name descname"><span class="pre">rebuild</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.Zipper.rebuild" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.right">
<span class="sig-name descname"><span class="pre">right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.right" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.t">
<span class="sig-name descname"><span class="pre">t</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ExprRef</span></em><a class="headerlink" href="#kdrag.utils.Zipper.t" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kdrag.utils.Zipper.up">
<span class="sig-name descname"><span class="pre">up</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><span class="pre">Zipper</span></a></span></span><a class="headerlink" href="#kdrag.utils.Zipper.up" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#kdrag.utils.Zipper" title="kdrag.utils.Zipper"><em>Zipper</em></a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.all_values">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">all_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">es</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.all_values" title="Link to this definition"></a></dt>
<dd><p>Generate all values possible for an expression. Generator won’t terminate if there are infinite possible values.
Concretization.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_values</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">If</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Bool</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span> <span class="o">==</span> <span class="p">{</span><span class="n">smt</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">3</span><span class="p">)}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>es</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[list[<em>ExprRef</em>], None, None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.alpha_eq">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">alpha_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.alpha_eq" title="Link to this definition"></a></dt>
<dd><p>Alpha equivalent equality.
Z3’s fast built-in t.eq is not alpha invariant.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">),</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">y</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span> <span class="c1"># syntactic equality</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha_eq</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alpha_eq</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span><span class="p">)[</span><span class="mi">3</span><span class="p">],</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1"># No beta equivalence</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.alpha_norm">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">alpha_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.alpha_norm" title="Link to this definition"></a></dt>
<dd><p>Recursively rename all variables in an expression to canonical names.
Printed form may become ambiguous because internally de Bruijn indices are used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">w</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Consts</span><span class="p">(</span><span class="s2">&quot;x y z w&quot;</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Real</span><span class="p">(</span><span class="s2">&quot;p&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">],</span> <span class="n">z</span> <span class="o">+</span> <span class="n">w</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">alpha_norm</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">))</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">alpha_norm</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">z</span><span class="p">,</span><span class="n">w</span><span class="p">],</span> <span class="n">z</span> <span class="o">+</span> <span class="n">w</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">alpha_norm</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">],</span> <span class="n">p</span><span class="p">))</span> <span class="o">==</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">p</span><span class="p">],</span> <span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>expr</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.antipattern">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">antipattern</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.antipattern" title="Link to this definition"></a></dt>
<dd><p>Anti pattern matching. Given a list of concrete examples, return the most specific pattern that matches them all.
Returns tuple of list of pattern variables and pattern expression.</p>
<p><a class="reference external" href="https://arxiv.org/pdf/2302.00277">https://arxiv.org/pdf/2302.00277</a> Anti-unification and Generalization: A Survey
<a class="reference external" href="https://arxiv.org/abs/2212.04596">https://arxiv.org/abs/2212.04596</a>  babble: Learning Better Abstractions with E-Graphs and Anti-Unification
<a class="reference external" href="https://ericlippert.com/2018/10/29/anti-unification-part-1/">https://ericlippert.com/2018/10/29/anti-unification-part-1/</a></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;a b c d&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">g</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">g</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">g</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">antipattern</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">])</span>
<span class="go">([a!..., b!...], f(a!..., g(a!..., b!...)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">antipattern</span><span class="p">([</span><span class="n">t1</span><span class="p">,</span><span class="n">t2</span><span class="p">,</span><span class="n">t3</span><span class="p">])</span>
<span class="go">([a!..., a!..., b!...], f(a!..., g(a!..., b!...)))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>xs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[list[<em>ExprRef</em>], <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.ast_size_sexpr">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">ast_size_sexpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">AstRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kdrag.utils.ast_size_sexpr" title="Link to this definition"></a></dt>
<dd><p>Get an approximate size of an AST node by its s-expression length.
This is probably faster than any python layer traversal one can do.
Pretty printed ast size will be correlated to expression size, maybe even DAG size,
since Z3 inserts <a href="#id3"><span class="problematic" id="id4">`</span></a>let`s to avoid duplication.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ast_size_sexpr</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ast_size_sexpr</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">))</span>
<span class="go">7</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>AstRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.bysect">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">bysect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.bysect" title="Link to this definition"></a></dt>
<dd><p>Bisect the <cite>by</cite> list to find a minimal set of premises that prove <cite>thm</cite>. Presents the same interface as <cite>prove</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">by</span> <span class="o">=</span> <span class="p">[</span><span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">),</span> <span class="n">kd</span><span class="o">.</span><span class="n">axiom</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">),</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">),</span> <span class="n">kd</span><span class="o">.</span><span class="n">axiom</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">z</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bysect</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">z</span><span class="p">,</span> <span class="n">by</span><span class="o">=</span><span class="n">by</span><span class="p">)</span>
<span class="go">[(1, |= x == y), (3, |= y == z)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>by</strong> (<em>list</em><em>[</em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>] </em><em>| </em><em>dict</em><em>[</em><em>object</em><em>, </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>]</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Sequence</em>[tuple[object, <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.consts">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">consts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.consts" title="Link to this definition"></a></dt>
<dd><p>Return all constants in a term.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consts</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">{</span><span class="n">smt</span><span class="o">.</span><span class="n">IntVal</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">}</span>
<span class="go">True</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>set[<em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.decls">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">decls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">FuncDeclRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.decls" title="Link to this definition"></a></dt>
<dd><p>Return all function declarations in a term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>set[<em>FuncDeclRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.defined_decls">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">defined_decls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">FuncDeclRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.defined_decls" title="Link to this definition"></a></dt>
<dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">kd</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;test_f&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;g&quot;</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">defined_decls</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[test_f]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>FuncDeclRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.find_calls">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">find_calls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">decl</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FuncDeclRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.find_calls" title="Link to this definition"></a></dt>
<dd><p>Find subterms that are calls of decl in t.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Function</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_calls</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">[f(f(4*f(3)) + 2), f(4*f(3)), f(3)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>decl</strong> (<em>FuncDeclRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.free_in">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">free_in</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.free_in" title="Link to this definition"></a></dt>
<dd><p>Returns True if none of the variables in vs exist unbound in t.
Distinct from <cite>occurs</cite> in that vs have to be constants, not general terms.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">free_in</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">free_in</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">free_in</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.free_vars">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">free_vars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.free_vars" title="Link to this definition"></a></dt>
<dd><p>Return free variables in an expression. Looks at kernel.defns to determine if contacts are free.
If you have meaningful constants no registered there, this may not work.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">free_vars</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="go">{y}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>set[<em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.generate">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">SortRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pred</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Generator</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.generate" title="Link to this definition"></a></dt>
<dd><p>A generator of values for a sort. Repeatedly calls z3 to get a new value.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">generate</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">BoolSort</span><span class="p">()))</span>
<span class="go">{True, False}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">generate</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">pred</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">smt</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">))])</span>
<span class="go">[0, 1, 2, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">islice</span><span class="p">(</span><span class="n">generate</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ArraySort</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">(),</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())),</span> <span class="mi">3</span><span class="p">)))</span>
<span class="go">3</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>sort</strong> (<em>SortRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Generator</em>[<em>ExprRef</em>, None, None]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.is_strict_subterm">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">is_strict_subterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.is_strict_subterm" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t2</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.is_subterm">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">is_subterm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.is_subterm" title="Link to this definition"></a></dt>
<dd><p>TODO: Not alpha invariant or going into binders</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t2</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.is_value">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">is_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.is_value" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.lemma_db">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">lemma_db</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.lemma_db" title="Link to this definition"></a></dt>
<dd><p>Scan all modules for Proof objects and return a dictionary of them.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict[str, <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.occurs">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">occurs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.occurs" title="Link to this definition"></a></dt>
<dd><p>Does x occur in t?</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">occurs</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">occurs</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">occurs</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">v0</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Var</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">IntSort</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">occurs</span><span class="p">(</span><span class="n">v0</span><span class="p">,</span> <span class="n">v0</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.open_binder">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">open_binder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">QuantifierRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.open_binder" title="Link to this definition"></a></dt>
<dd><p>Open a quantifier with fresh variables. This achieves the locally nameless representation
<a class="reference external" href="https://chargueraud.org/research/2009/ln/main.pdf">https://chargueraud.org/research/2009/ln/main.pdf</a>
where it is harder to go wrong.</p>
<p>The variables are schema variables which when used in a proof may be generalized</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">open_binder</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([X!...], X!... &gt; 0)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lam</strong> (<em>QuantifierRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[list[<em>ExprRef</em>], <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.open_binder_unhygienic">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">open_binder_unhygienic</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lam</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">QuantifierRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.open_binder_unhygienic" title="Link to this definition"></a></dt>
<dd><p>Do not use this. Use <cite>open_binder</cite>. Opens a quantifier with unfresh variables.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">open_binder_unhygienic</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
<span class="go">([x], x &gt; 0)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>lam</strong> (<em>QuantifierRef</em>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[list[<em>ExprRef</em>], <em>ExprRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.pathmap">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">pathmap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">e</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ExprRef</span></span></span><a class="headerlink" href="#kdrag.utils.pathmap" title="Link to this definition"></a></dt>
<dd><p>Apply function at position in term
&gt;&gt;&gt; x,y,z = smt.Ints(“x y z”)
&gt;&gt;&gt; pathmap(lambda t: t + 1, x + y * z, [1,0])
x + (y + 1)*z</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function</strong> (<em>Callable</em><em>[</em><em>[</em><em>ExprRef</em><em>]</em><em>, </em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>e</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>path</strong> (<em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>None</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>ExprRef</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.pmatch">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">pmatch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.pmatch" title="Link to this definition"></a></dt>
<dd><p>Pattern match t against pat considering vs as variables. Returns substitution dictionary if succeeds
<a class="reference external" href="https://www.philipzucker.com/ho_unify/">https://www.philipzucker.com/ho_unify/</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>pat</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[<em>ExprRef</em>, <em>ExprRef</em>] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.pmatch_fo">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">pmatch_fo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subst</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.pmatch_fo" title="Link to this definition"></a></dt>
<dd><p>First order pattern matching. Faster and simpler.
Pattern match t against pat considering vs as variables. Returns substitution dictionary if succeeds</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pmatch_fo</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="go">{x: y}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>pat</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[<em>ExprRef</em>, <em>ExprRef</em>] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.pmatch_rec">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">pmatch_rec</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">into_binder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.pmatch_rec" title="Link to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>pat</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<em>ExprRef</em>, dict[<em>ExprRef</em>, <em>ExprRef</em>]] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.pmatch_rec_ctx">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">pmatch_rec_ctx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><span class="pre">ExprCtx</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.pmatch_rec_ctx" title="Link to this definition"></a></dt>
<dd><p>Pattern match <cite>pat</cite> against subterms of <cite>t</cite>, returning the context, matched term, and substitution if successful.
&gt;&gt;&gt; x,y,z,a,b = smt.Ints(“x y z a b”)
&gt;&gt;&gt; kd.utils.pmatch_rec_ctx([a,b], a*b, smt.Lambda([x], x * y))
([LambdaHole(vs=[X!…], orig_vs=[x])], X!…*y, {b: y, a: X!…})</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>pat</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>t</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>tuple[<a class="reference internal" href="#kdrag.utils.ExprCtx" title="kdrag.utils.ExprCtx"><em>ExprCtx</em></a>, <em>ExprRef</em>, dict[<em>ExprRef</em>, <em>ExprRef</em>]] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.prompt">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">prompt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prompt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.prompt" title="Link to this definition"></a></dt>
<dd><p>Ask an AI.</p>
<p>Get the root directory of the current package, find all .py files within
that directory, and concatenate their contents into a single string separated by <cite>—</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A single string with all .py files concatenated, separated by <cite>—</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>prompt</strong> (<em>str</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.propagate">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">maybes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">BoolRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BoolRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">BoolRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.propagate" title="Link to this definition"></a></dt>
<dd><p>Prune the list of maybes to the ones implies by known</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Bools</span><span class="p">(</span><span class="s2">&quot;p q r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">propagate</span><span class="p">([</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">smt</span><span class="o">.</span><span class="n">And</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)],</span> <span class="n">p</span> <span class="o">&amp;</span> <span class="n">q</span><span class="p">)</span>
<span class="go">[p, q, And(p, q)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>maybes</strong> (<em>list</em><em>[</em><em>BoolRef</em><em>]</em>)</p></li>
<li><p><strong>known</strong> (<em>BoolRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>BoolRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.propagate_eqs">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">propagate_eqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">terms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">known</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BoolRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">BoolRef</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.propagate_eqs" title="Link to this definition"></a></dt>
<dd><p>Given a list of terms, propagate equalities among them that are implied by known.
&gt;&gt;&gt; x,y,z = smt.Ints(“x y z”)
&gt;&gt;&gt; terms = [x, y, z, x + 1, y + 1]
&gt;&gt;&gt; known = smt.And(x == y, y == z)
&gt;&gt;&gt; propagate_eqs(terms, known)
[y == x, z == x, z == y, y + 1 == x + 1]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>terms</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>known</strong> (<em>BoolRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>BoolRef</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.prune">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">prune</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">BoolRef</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">QuantifierRef</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">by</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.prune" title="Link to this definition"></a></dt>
<dd><p>Prune the theorems used using unsat core. Helpful to speedup future proof verification.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Bools</span><span class="p">(</span><span class="s2">&quot;p q r&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">sorted</span><span class="p">(</span><span class="n">prune</span><span class="p">(</span><span class="n">p</span> <span class="o">&amp;</span> <span class="n">q</span><span class="p">,</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">decl</span><span class="p">()</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
<span class="go">[p, q]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>thm</strong> (<em>BoolRef</em><em> | </em><em>QuantifierRef</em><em> | </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[<em>ExprRef</em> | <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.quant_kind_eq">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">quant_kind_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">QuantifierRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">QuantifierRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kdrag.utils.quant_kind_eq" title="Link to this definition"></a></dt>
<dd><p>Check both quantifiers are of the same kind</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Int</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forall</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exists</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Exists</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lamb</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Lambda</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">quant_kind_eq</span><span class="p">(</span><span class="n">forall</span><span class="p">,</span> <span class="n">forall</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">quant_kind_eq</span><span class="p">(</span><span class="n">exists</span><span class="p">,</span> <span class="n">exists</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">quant_kind_eq</span><span class="p">(</span><span class="n">lamb</span><span class="p">,</span> <span class="n">lamb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="ow">not</span> <span class="n">quant_kind_eq</span><span class="p">(</span><span class="n">forall</span><span class="p">,</span> <span class="n">exists</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>t1</strong> (<em>QuantifierRef</em>)</p></li>
<li><p><strong>t2</strong> (<em>QuantifierRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.sanity_check_consistency">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">sanity_check_consistency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">thms</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timeout</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.sanity_check_consistency" title="Link to this definition"></a></dt>
<dd><p>Sanity check theorems or proofs for consistency. If they are inconsistent, raise an error.
Otherwise, return the result of the check. A sat result shows consistency, but an unknown result does not imply anything.</p>
<p>It may be nice to try and apply this function to your axioms or theory in CI.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sanity_check_consistency</span><span class="p">([</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">])</span>
<span class="go">sat</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>thms</strong> (<em>list</em><em>[</em><em>ExprRef</em><em> | </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.search">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">es</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FuncDeclRef</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{}</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.search" title="Link to this definition"></a></dt>
<dd><p>Search for function declarations or expressions.
Takes intersection of found results if given multiple arguments.
Builds a database by scanning loaded modules by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>es</strong> (<em>FuncDeclRef</em><em> | </em><em>ExprRef</em>)</p></li>
<li><p><strong>db</strong> (<em>dict</em><em>[</em><em>Any</em><em>, </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[tuple[str, <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>], <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.search_decl">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">search_decl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">FuncDeclRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">db</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.search_decl" title="Link to this definition"></a></dt>
<dd><p>Search for declarations in the proof database that contain function declaration f</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>f</strong> (<em>FuncDeclRef</em>)</p></li>
<li><p><strong>db</strong> (<em>dict</em><em>[</em><em>object</em><em>, </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[tuple[str, <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>], <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.search_expr">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">search_expr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">e</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pfs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><span class="pre">Proof</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">Any</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#kdrag.utils.search_expr" title="Link to this definition"></a></dt>
<dd><p>Search for expressions in the proof database that match <cite>e</cite> using pattern matching.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x z&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_expr</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="p">{</span>        <span class="s2">&quot;thm1&quot;</span><span class="p">:</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">x</span><span class="p">)),</span>        <span class="s2">&quot;thm2&quot;</span> <span class="p">:</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">z</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">z</span><span class="p">),</span>        <span class="s2">&quot;thm3&quot;</span> <span class="p">:</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">x</span><span class="p">)),</span>        <span class="s2">&quot;thm4&quot;</span> <span class="p">:</span> <span class="n">kd</span><span class="o">.</span><span class="n">prove</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">BoolVal</span><span class="p">(</span><span class="kc">True</span><span class="p">))})</span>
<span class="go">{(&#39;thm1&#39;, |= ForAll(x, x + 0 == x)): [z], (&#39;thm2&#39;, |= z + 0 == z): []}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>e</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>pfs</strong> (<em>dict</em><em>[</em><em>object</em><em>, </em><a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[tuple[str, <a class="reference internal" href="kdrag.kernel.html#kdrag.kernel.Proof" title="kdrag.kernel.Proof"><em>Proof</em></a>], <em>Any</em>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.sorts">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">sorts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.sorts" title="Link to this definition"></a></dt>
<dd><p>Generate all sorts in a term</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.subterms">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">subterms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">into_binder</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kdrag.utils.subterms" title="Link to this definition"></a></dt>
<dd><p>Generate all subterms of a term</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">smt</span><span class="o">.</span><span class="n">Ints</span><span class="p">(</span><span class="s2">&quot;x y&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subterms</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="p">))</span>
<span class="go">[x + y == y, y, x + y, y, x]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subterms</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="p">)))</span>
<span class="go">[ForAll(x, x + y == y)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">subterms</span><span class="p">(</span><span class="n">smt</span><span class="o">.</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">==</span> <span class="n">y</span><span class="p">),</span> <span class="n">into_binder</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">[ForAll(x, x + y == y), Var(0) + y == y, y, Var(0) + y, y, Var(0)]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>ExprRef</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.unify">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">unify</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.unify" title="Link to this definition"></a></dt>
<dd><p>Unification</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vs</strong> (<em>list</em><em>[</em><em>ExprRef</em><em>]</em>)</p></li>
<li><p><strong>p1</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>p2</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[<em>ExprRef</em>, <em>ExprRef</em>] | None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kdrag.utils.unify_db">
<span class="sig-prename descclassname"><span class="pre">kdrag.utils.</span></span><span class="sig-name descname"><span class="pre">unify_db</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ExprRef</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">ExprRef</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">ExprRef</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#kdrag.utils.unify_db" title="Link to this definition"></a></dt>
<dd><p>Unification using de Bruijn indices as variables</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p1</strong> (<em>ExprRef</em>)</p></li>
<li><p><strong>p2</strong> (<em>ExprRef</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict[<em>ExprRef</em>, <em>ExprRef</em>] | None</p>
</dd>
</dl>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="kdrag.theories.sexp.parse.html" class="btn btn-neutral float-left" title="kdrag.theories.sexp.parse" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="kdrag.utils.all_values.html" class="btn btn-neutral float-right" title="kdrag.utils.all_values" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Philip Zucker.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>