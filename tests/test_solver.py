import pytest
import kdrag as kd
from kdrag.solvers import (
    VampireTHFSolver,
    EProverTHFSolver,
    MultiSolver,
    ZipperpositionSolver,
    TweeSolver,
    SATSolver,
    LeanSolver,
)
import kdrag.solvers as solvers
import kdrag.smt as smt
import kdrag.theories.real as real
import shutil
from kdrag.solvers.egglog import EgglogSolver
import kdrag.solvers.gappa as gappa
import kdrag.solvers.aprove
import kdrag.solvers.kb as kb
import kdrag.rewrite as rw

@pytest.mark.slow
def test_vampirethf():
    s = VampireTHFSolver()
    s.add(smt.BoolVal(True))
    assert s.check() == smt.sat

    s = VampireTHFSolver()
    s.add(smt.BoolVal(False))
    assert s.check() == smt.unsat

    s = VampireTHFSolver()
    p, q, r = smt.Bools("p q r")
    s.add(smt.Implies(p, q))
    s.add(p)
    s.add(smt.Not(q))
    assert s.check() == smt.unsat

    # extensionality`
    """ Need HO vampire
    s = VampireTHFSolver()
    S = smt.DeclareSort("S")
    T = smt.DeclareSort("T")
    x = smt.Const("x", S)
    f, g = smt.Consts("f g", S >> T)
    s.add(f == g)
    s.add(smt.Not(smt.ForAll([x], (f(x) == g(x)))))
    assert s.check() == smt.unsat

    x, y, z = smt.Reals("x y z")
    s = VampireTHFSolver()
    s.add(x + y == z)
    s.add(x == y)
    assert s.check() == smt.sat
    """

    S = smt.DeclareSort("S")
    T = smt.DeclareSort("T")
    x, y, z = smt.Consts("x y z", S)
    f, g = smt.Consts("f g", S >> T)

    """
    s = VampireTHFSolver()
    s.add(f == g)
    s.add(smt.Not(smt.ForAll([x], (f(x) == g(x)))))
    assert s.check() == smt.unsat
    """
    s = EProverTHFSolver()
    s.add(f == g)
    s.add(smt.Not(smt.ForAll([x], (f(x) == g(x)))))
    assert s.check() == smt.unsat

    s = EProverTHFSolver()
    f, g = smt.Consts("f g", S >> S)
    s.add(smt.Not(smt.Implies(smt.ForAll([x], (f(x) == x)), f == smt.Lambda([x], x))))
    assert s.check() == smt.unsat

    x, y, z = smt.Reals("x y z")
    s = EProverTHFSolver()
    s.add(real.abstract_arith(x + y == z))
    s.add(real.abstract_arith(x != z - y))
    s.add(real.sub_add.thm)
    assert s.check() == smt.unsat

    s = MultiSolver()
    s.add(smt.BoolVal(False))
    assert s.check() == smt.unsat

    if shutil.which("zipperposition") is not None:
        s = ZipperpositionSolver()
        s.add(smt.BoolVal(True))
        assert s.check() == smt.unknown

    # s = MultiSolver()
    # s.add(smt.BoolVal(True))

    # Does not pass. TODO: Need to fix intrinsics
    # kd.prove(smt.Or(smt.BoolVal(False), smt.BoolVal(True)), solver=EProverTHFSolver)

    kd.kernel.prove(
        smt.Or(smt.BoolVal(False), smt.BoolVal(True)), solver=EProverTHFSolver
    )

    # https://www.cl.cam.ac.uk/~jrh13/hol-light/manual-1.1.pdf
    kd.kernel.prove(
        smt.Lambda([x], x) == smt.Lambda([y], y),
        solver=EProverTHFSolver,
    )

    kd.kernel.prove(smt.Lambda([x], x) == smt.Lambda([y], y))

    f = smt.Const("f", smt.BoolSort() >> smt.BoolSort())
    p, q = smt.Bools("p q")

    kd.kernel.prove(
        smt.ForAll(
            [p],
            p == (smt.Lambda([f], f(p)) == smt.Lambda([f], f(smt.BoolVal(True)))),
        ),
        solver=EProverTHFSolver,
    )

    s = TweeSolver()
    x, y, z = smt.Consts("x y z", S)
    s.add(x == y)
    s.add(y == z)
    s.add(smt.Not(x == z))
    s.check()
    """
    f = smt.Const("f", smt.BoolSort() >> (smt.BoolSort() >> smt.IntSort()))
    kd.kernel.prove(
        smt.ForAll(
            [p, q],
            smt.And(p, q)
            == (
                smt.Lambda([f], f(p)(q))
                == smt.Lambda([f], f(smt.BoolVal(True))(smt.BoolVal(True)))
            ),
        ),
        solver=EProverTHFSolver,
    )
    """
    """
    kd.kernel.prove(
        kd.QForAll(
            [p, q],
            smt.And(p, q)
            == (
                smt.ForAll([f], f(p)(q))
                == smt.ForAll([f], f(smt.BoolVal(True))(smt.BoolVal(True)))
            ),
        ),
        solver=EProverTHFSolver,
    )
    
    kd.kernel.prove(
        kd.QForAll(
            [p, q],
            smt.And(p, q),
            smt.Lambda([f], f(p)(q))
            == smt.Lambda([f], f(smt.BoolVal(True))(smt.BoolVal(True))),
        ),
        solver=EProverTHFSolver,
    )
    """

    """
    % TPTP file generated by Knuckledragger
    % Declarations
    % Axioms and assertions

    thf(d1, type, a : $i).
    thf(d2, type, b : $i).
    thf(ax, axiom, a != b).
    thf(ax, axiom, ![X : $i] : ((X = a) | (X = b))).
    thf(ax_0, axiom, ~((![P_123:$o] : (P_123 = ((^[F_120:($o > $i)] : (F_120 @ P_123)) = (^[F_120:($o > $i)] : (F_120 @ $true))))))).

    %thf(ax_0, axiom, ~((![P_123:$o] : (P_123 = ((^[F_120:($o > $o)] : (F_120 @ P_123)) = (^[F_120:($o > $o)] : (F_120 @ $true))))))).
    %thf(ax_0, axiom, ~((![P_123:$o] : (P_123 = ((![F_120:($o > $o)] : ((F_120 @ P_123) = (F_120 @ $true)))))))).
    %thf(ax_0, axiom, ~((![P_123:$o] : (P_123 = ((![F_120:($o > $i)] : ((F_120 @ P_123) = (F_120 @ $true)))))))).
    
    %  --mode {best|fo-complete-basic|ho-comb-complete|ho-competitive
    %|ho-complete-basic|ho-pragmatic|lambda-free-extensional|lambda-free-intensional|lambda-free-purify-extensional|lambda-free-purify-intensional}
    """


"""
TODO: Yeah, the entire refutation idea doesn't work here.
def test_nanocopi():
    s = solvers.NanoCopISolver()
    p, q, r = smt.Bools("p q r")
    s.add(smt.Or(p, smt.Not(p)))
    assert s.check() == smt.unsat
"""


@pytest.mark.slow
def test_tao():
    # https://www.philipzucker.com/tao_algebra/
    T = smt.DeclareSort("T")
    x, y, z = smt.Consts("x y z", T)
    mul = smt.Function("mul", T, T, T)
    kd.notation.mul.define([x, y], mul(x, y))

    def check(s):
        s.add(smt.ForAll([x, y], (x * x) * y == y * x))
        s.add(smt.Not(smt.ForAll([x, y], x * y == y * x)))
        return s.check()

    assert check(TweeSolver()) == smt.unsat
    assert check(VampireTHFSolver()) == smt.unsat
    assert check(EProverTHFSolver()) == smt.unsat
    assert check(MultiSolver()) == smt.unsat
    if shutil.which("zipperposition") is not None:
        assert check(ZipperpositionSolver()) == smt.unsat
    assert check(smt.Solver()) == smt.unsat
    assert check(solvers.VampireSolver()) == smt.unsat


def test_egglog():
    e = EgglogSolver(debug=True)
    x, y, z = smt.Consts("x y z", smt.IntSort())
    f = smt.Function("f", smt.IntSort(), smt.IntSort())
    e.add(x == y)
    e.add(smt.ForAll([x], f(x) == f(f(y))))
    e.let("t", f(f(x)))
    e.run(10)
    assert e.extract(f(x)) == ["(f (y))"] or e.extract(f(x)) == ["(f (x))"]


def test_satsolver():
    s = SATSolver()
    x, y, z = smt.Bools("x y z")
    s.add(x == y)
    s.add(y == z)
    assert s.check() == smt.sat
    s.add(x != z)
    assert s.check() == smt.unsat


def test_vampire_question_answer():
    s = solvers.VampireSolver()
    x, y, z = smt.Ints("x y z")
    res = s.query(smt.Exists([x], x > 3))
    assert len(res) == 1
    assert "% SZS answers Tuple" in s.res.stdout.decode()
    T = smt.DeclareSort("T")
    y = smt.Const("y", T)
    f = smt.Function("f", T, smt.BoolSort())
    s = solvers.VampireSolver()
    s.add(f(y))
    res = s.query(smt.Exists([y], f(y)))
    assert re.fullmatch(
        r"\% SZS answers Tuple \[\[y_[0-9a-f]*\]\|_\] for vampire", res[0]
    )


def test_gappa():
    x, y = smt.Reals("x y")
    assert (
        gappa.gappa_of_bool(smt.Implies(smt.And(x <= 2, x >= -2 / 8), x * x <= 4))
        == "(((x <= 2) /\\ (x >= -0.25)) -> ((x * x) <= 4))"
    )
    s = gappa.GappaSolver()
    s.add(smt.Implies(smt.And(x <= 2, x >= -1 / 128), x * x <= 4))
    s.check()
    s.bound(x * x)


import re


def test_fof():
    x = smt.Int("x")
    assert re.match(
        r"\(!\[Xbang[0-9]+_(?P<var_num>[a-zA-Z0-9]+)\] : \(\$greater\(Xbang[0-9]+_(?P=var_num),4\) & \$lesseq\(Xbang[0-9]+_(?P=var_num),7\)\)\)",
        kd.solvers.expr_to_tptp(smt.ForAll([x], smt.And(x > 4, x <= 7)), format="fof"),
    )


def test_tptp():
    x = smt.Int("x")
    assert (
        re.match(
            r"\(\$greater\(x_[0-9a-f]+,4\) & \$lesseq\(x_[0-9a-f]+,7\)\)",
            kd.solvers.expr_to_tptp(smt.And(x > 4, x <= 7)),
        )
        is not None
    )
    assert kd.solvers.sort_to_tptp(smt.IntSort()) == "$int"
    assert kd.solvers.sort_to_tptp(smt.BoolSort()) == "$o"
    assert (
        kd.solvers.sort_to_tptp(
            smt.ArraySort(smt.ArraySort(smt.BoolSort(), smt.IntSort()), smt.IntSort())
        )
        == "(($o > $int) > $int)"
    )


"""
TODO: Not installing aprove in CI?
def test_aprove():
    plus = smt.Function("plus", smt.IntSort(), smt.IntSort(), smt.IntSort())
    x, y, z = smt.Ints("x y z")
    succ = smt.Function("succ", smt.IntSort(), smt.IntSort())
    zero = smt.IntVal(0)
    kd.solvers.aprove.run_aprove(
        [x, y], [plus(x, zero) == x, plus(x, succ(y)) == succ(plus(x, y))]
    )
"""


def test_tptp2smt():
    # https://tptp.org/UserDocs/QuickGuide/
    # https://tptp.org/cgi-bin/SeeTPTP?Category=Problems&Domain=SYN&File=SYN075+1.p
    example = """
    fof(pel52_1,axiom,
    ? [Z,W] :
    ! [X,Y] :
      ( big_f(X,Y)
    <=> ( X = Z
        & Y = W ) ) ).

fof(pel52,conjecture,
    ? [W] :
    ! [Y] :
      ( ? [Z] :
        ! [X] :
          ( big_f(X,Y)
        <=> X = Z )
    <=> Y = W ) ).

    """
    open("/tmp/example.p", "w").write(example)
    constrs = solvers.tptp2smt("/tmp/example.p")
    s = smt.Solver()
    s.add(constrs)
    assert s.check() == smt.unsat

    # https://tptp.org/cgi-bin/SeeTPTP?Category=Problems&Domain=PUZ&File=PUZ131_1.p
    # ok I guess tff doesn't work to smt2 for tptp4x
    example = """tff(student_type,type,
        student: $tType ).

    tff(professor_type,type,
        professor: $tType ).

    tff(course_type,type,
        course: $tType ).

    tff(michael_type,type,
        michael: student ).

    tff(victor_type,type,
        victor: professor ).

    tff(csc410_type,type,
        csc410: course ).

    tff(enrolled_type,type,
        enrolled: ( student * course ) > $o ).

    tff(teaches_type,type,
        teaches: ( professor * course ) > $o ).

    tff(taught_by_type,type,
        taughtby: ( student * professor ) > $o ).

    tff(coordinator_of_type,type,
        coordinatorof: course > professor ).

    tff(student_enrolled_axiom,axiom,
        ! [X: student] :
        ? [Y: course] : enrolled(X,Y) ).

    tff(professor_teaches,axiom,
        ! [X: professor] :
        ? [Y: course] : teaches(X,Y) ).

    tff(course_enrolled,axiom,
        ! [X: course] :
        ? [Y: student] : enrolled(Y,X) ).

    tff(course_teaches,axiom,
        ! [X: course] :
        ? [Y: professor] : teaches(Y,X) ).

    tff(coordinator_teaches,axiom,
        ! [X: course] : teaches(coordinatorof(X),X) ).

    tff(student_enrolled_taught,axiom,
        ! [X: student,Y: course] :
        ( enrolled(X,Y)
        => ! [Z: professor] :
            ( teaches(Z,Y)
            => taughtby(X,Z) ) ) ).

    tff(michael_enrolled_csc410_axiom,axiom,
        enrolled(michael,csc410) ).

    tff(victor_coordinator_csc410_axiom,axiom,
        coordinatorof(csc410) = victor ).

    tff(teaching_conjecture,conjecture,
        taughtby(michael,victor) ).
    """
    #open("/tmp/example.p", "w").write(example)
    #constrs = solvers.tptp2smt("/tmp/example.p")
    #s = smt.Solver()
    #s.add(constrs)
    #assert s.check() == smt.unsat

    # https://tptp.org/cgi-bin/SeeTPTP?Category=Problems&Domain=SYN&File=SYN075-1.p
    example = """
cnf(clause_1,axiom,
    ( ~ big_f(X,Y)
    | X = a ) ).

cnf(clause_2,axiom,
    ( ~ big_f(X,Y)
    | Y = b ) ).

cnf(clause_3,axiom,
    ( X != a
    | Y != b
    | big_f(X,Y) ) ).

cnf(clause_4,negated_conjecture,
    ( ~ big_f(Y,f(X))
    | Y != g(X)
    | f(X) = X ) ).

cnf(clause_5,negated_conjecture,
    ( ~ big_f(Y,f(X))
    | Y = g(X)
    | big_f(h(X,Z),f(X))
    | ~ big_f(h(X,Z),f(X)) ) ).

cnf(clause_6,negated_conjecture,
    ( Y != g(X)
    | big_f(Y,f(X))
    | f(X) = X ) ).

cnf(clause_7,negated_conjecture,
    ( Y != g(X)
    | big_f(Y,f(X))
    | big_f(h(X,Z),f(X))
    | h(X,Z) = Z ) ).

cnf(clause_8,negated_conjecture,
    ( Y != g(X)
    | big_f(Y,f(X))
    | h(X,Z) != Z
    | ~ big_f(h(X,Z),f(X)) ) ).

cnf(clause_9,negated_conjecture,
    ( f(X) != X
    | big_f(h(X,Z),f(X))
    | h(X,Z) = Z ) ).

cnf(clause_10,negated_conjecture,
    ( f(X) != X
    | h(X,Z) != Z
    | ~ big_f(h(X,Z),f(X)) ) ).
    """
    open("/tmp/example.p", "w").write(example)
    constrs = solvers.tptp2smt("/tmp/example.p")
    s = smt.Solver()
    s.add(constrs)
    assert s.check() == smt.unsat


def test_smt2tptp():
    example = """

    (declare-const x Int)
    (declare-const y Int)
    (declare-const z Int)
    (declare-const a Real)
    (declare-sort T 0)
    (declare-fun f (T T) Bool)
    (declare-const student T)
    (assert (and (>= x 0) (<= x 10)))
    (assert (and (>= y 0) (<= y 10)))
    (assert (> y 10))
    (assert (f student student))
    (assert (> a 0))
    """
    open("/tmp/example.smt2", "w").write(example)
    solvers.smt2tptp("/tmp/example.smt2", "/tmp/example.p", "tff")
    solvers.run("vampire", ["/tmp/example.p"], check=True)


@pytest.mark.slow
def test_huet():
    # Gropu theory example
    # https://smimram.github.io/ocaml-alg/kb/

    # With and without caching in kdrag.smt makes a big difference

    T = smt.DeclareSort("AbstractGroup")
    x,y,z = smt.Consts("x y z", T)
    e = smt.Const("a_e", T)
    inv = smt.Function("c_inv", T, T)
    mul = smt.Function("b_mul", T, T, T)
    kd.notation.mul.register(T, mul)
    kd.notation.invert.register(T, inv)
    E = [
        smt.ForAll([x], e * x == x),
        # adding in these other redundant axioms makes it easier on the system
        #smt.ForAll([x], x * e == x),
        #smt.ForAll([x], x * inv(x) == e),
        smt.ForAll([x], inv(x) * x == e),
        smt.ForAll([x,y,z], (x * y) * z == x * (y * z)),
        #smt.ForAll([x,y], inv(x * y) == inv(y) * inv(x))
    ]
    #basic(E, order=rw.lpo)
    assert len(kb.huet(E, order=rw.lpo)) == 10


def test_huet_smt():
    example = """\
(declare-sort T 0)
(declare-fun mul (T T) T)
(assert 
    (forall ((x T) (y T) (z T))
    (=  (mul (mul x y) (mul y z)) 
        y))
)"""
    open("/tmp/central_groupoid.smt2", "w").write(example)
    assert len(kb.huet_smt2_file("/tmp/central_groupoid.smt2")) == 3

def test_lean_fast():
    s = LeanSolver()
    x,y,z = smt.Bools("x y z")
    s.add(smt.Not(smt.ForAll([x], x == x)))
    assert s.check() == smt.unsat

@pytest.mark.slow
def test_lean():
    s = LeanSolver()
    x,y,z = smt.Bools("x y z")
    s.add(smt.Not(smt.ForAll([x], x == x)))
    assert s.check() == smt.unsat

    x,y,z = smt.Ints("x y z")
    s = LeanSolver()
    s.add(smt.Not(smt.ForAll([x,y], x + y == y + x)))
    assert s.check() == smt.unsat

    s = LeanSolver()
    s.add(smt.Not(smt.ForAll([x,y], x + 1 >= x)))
    s.check()


    s = LeanSolver()
    x,y,z = smt.Bools("x y z")
    s.add(smt.Not(smt.Implies(smt.And(x, y), x)))
    s.check()

    s = LeanSolver()
    x,y,z = smt.Bools("x y z")
    s.add(smt.Not(smt.Implies(smt.Or(x, y), x)))
    assert s.check() != smt.unsat

    s = LeanSolver()
    x,y,z = smt.Bools("x y z")
    s.add(smt.Not(smt.Implies(x, smt.Or(x, y, z))))
    assert s.check() == smt.unsat

    def testit(expr):
        s = LeanSolver()
        s.add(expr)
        res = s.check()
        assert res == smt.unsat, f"Expected unsat, got {res} for {expr}"

    testit(smt.Not(smt.ForAll([x,y], x + y == y + x)))

    x,y,z = smt.BitVecs("x y z", 8)
    testit(smt.Not(smt.ForAll([x,y], x + y == y + x)))
    testit(smt.Not(smt.ForAll([x,y], x | x == x)))


    # uninterpreted functions
    x,y,z = smt.Ints("x y z")
    f = smt.Function("f", smt.IntSort(), smt.IntSort())
    s = LeanSolver()
    s.add(smt.ForAll([x], f(x) == x))
    s.add(smt.Not(f(f(y)) == y))
    assert s.check() == smt.unsat


    # Uninterpreted sorts
    S = smt.DeclareSort("S")
    n = smt.Const("n", S)
    f = smt.Function("f", S, S)
    s = LeanSolver()
    s.add(f(n) == n)
    s.add(f(f(n)) != n)
    assert s.check() == smt.unsat

    # Inductive Datatypes
    #from kdrag.theories.nat import Nat
    MyNat = smt.Datatype("MyNat")
    MyNat.declare("Z")
    MyNat.declare("S", ("pred", MyNat))
    MyNat = MyNat.create()
    n = smt.Const("n", MyNat)

    s = LeanSolver()

    s.add(smt.Not(smt.ForAll([n], MyNat.S(n).pred == n)))
    assert s.check() == smt.unsat