"""
This type stub file was generated by pyright.
"""

import sys
from typing import Any
# from .z3core import *
# from .z3types import *
# from .z3consts import *
# from .z3printer import *

"""Z3 is a high performance theorem prover developed at Microsoft Research.

Z3 is used in many applications such as: software/hardware verification and testing,
constraint solving, analysis of hybrid systems, security, biology (in silico analysis),
and geometrical problems.


Please send feedback, comments and/or corrections on the Issue tracker for
https://github.com/Z3prover/z3.git. Your comments are very valuable.

Small example:

>>> x = Int('x')
>>> y = Int('y')
>>> s = Solver()
>>> s.add(x > 0)
>>> s.add(x < 2)
>>> s.add(y == x + 1)
>>> s.check()
sat
>>> m = s.model()
>>> m[x]
1
>>> m[y]
2

Z3 exceptions:

>>> try:
...   x = BitVec('x', 32)
...   y = Bool('y')
...   # the expression x + y is type incorrect
...   n = x + y
... except Z3Exception as ex:
...   print("failed: %s" % ex)
failed: sort mismatch
"""
if sys.version_info.major >= 3: ...
Z3_DEBUG = ...

def z3_debug():  # -> bool:
    ...

if sys.version_info.major < 3: ...
else: ...

def enable_trace(msg):  # -> None:
    ...
def disable_trace(msg):  # -> None:
    ...
def get_version_string():  # -> str:
    ...
def get_version():  # -> tuple[int, int, int, int]:
    ...
def get_full_version():  # -> Any | Literal['']:
    ...
def open_log(fname):  # -> None:
    """Log interaction to a file. This function must be invoked immediately after init()."""
    ...

def append_log(s):  # -> None:
    """Append user-defined string to interaction log."""
    ...

def to_symbol(s, ctx=...):  # -> Any:
    """Convert an integer or string into a Z3 symbol."""
    ...

def z3_error_handler(c, e):  # -> None:
    ...

class Context:
    """A Context manages all other Z3 objects, global configuration options, etc.

    Z3Py uses a default global context. For most applications this is sufficient.
    An application may use multiple Z3 contexts. Objects created in one context
    cannot be used in another one. However, several objects may be "translated" from
    one context to another. It is not safe to access Z3 objects from multiple threads.
    The only exception is the method `interrupt()` that can be used to interrupt() a long
    computation.
    The initialization method receives global configuration options for the new context.
    """
    def __init__(self, *args, **kws) -> None: ...
    def __del__(self):  # -> None:
        ...
    def ref(self):  # -> Any | None:
        """Return a reference to the actual C pointer to the Z3 context."""
        ...

    def interrupt(self):  # -> None:
        """Interrupt a solver performing a satisfiability test, a tactic processing a goal, or simplify functions.

        This method can be invoked from a thread different from the one executing the
        interruptible procedure.
        """
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the global parameter description set."""
        ...

_main_ctx = ...

def main_ctx():  # -> Context:
    """Return a reference to the global Z3 context.

    >>> x = Real('x')
    >>> x.ctx == main_ctx()
    True
    >>> c = Context()
    >>> c == main_ctx()
    False
    >>> x2 = Real('x', c)
    >>> x2.ctx == c
    True
    >>> eq(x, x2)
    False
    """
    ...

def get_ctx(ctx):  # -> Context:
    ...
def set_param(*args, **kws):  # -> None:
    """Set Z3 global (or module) parameters.

    >>> set_param(precision=10)
    """
    ...

def reset_params():  # -> None:
    """Reset all global (or module) parameters."""
    ...

def set_option(*args, **kws):  # -> None:
    """Alias for 'set_param' for backward compatibility."""
    ...

def get_param(name):  # -> Any | Literal['']:
    """Return the value of a Z3 global (or module) parameter

    >>> get_param('nlsat.reorder')
    'true'
    """
    ...

class Z3PPObject:
    """Superclass for all Z3 objects that have support for pretty printing."""
    def use_pp(self):  # -> Literal[True]:
        ...

class AstRef(Z3PPObject):
    """AST are Direct Acyclic Graphs (DAGs) used to represent sorts, declarations and expressions."""
    def __init__(self, ast, ctx=...) -> None: ...
    def __del__(self):  # -> None:
        ...
    def __deepcopy__(
        self, memo=...
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def __str__(self) -> str: ...
    def __repr__(self):  # -> str:
        ...
    def __eq__(self, other) -> bool: ...
    def __hash__(self) -> int: ...
    def __nonzero__(self):  # -> bool:
        ...
    def __bool__(self):  # -> bool:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a string representing the AST node in s-expression notation.

        >>> x = Int('x')
        >>> ((x + 1)*x).sexpr()
        '(* (+ x 1) x)'
        """
        ...

    def as_ast(self):  # -> Any | None:
        """Return a pointer to the corresponding C Z3_ast object."""
        ...

    def get_id(self):  # -> Any:
        """Return unique identifier for object. It can be used for hash-tables and maps."""
        ...

    def ctx_ref(self):  # -> Any | None:
        """Return a reference to the C context where this AST node is stored."""
        ...

    def eq(self, other):  # -> Any:
        """Return `True` if `self` and `other` are structurally identical.

        >>> x = Int('x')
        >>> n1 = x + 1
        >>> n2 = 1 + x
        >>> n1.eq(n2)
        False
        >>> n1 = simplify(n1)
        >>> n2 = simplify(n2)
        >>> n1.eq(n2)
        True
        """
        ...

    def translate(
        self, target
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`.

        >>> c1 = Context()
        >>> c2 = Context()
        >>> x  = Int('x', c1)
        >>> y  = Int('y', c2)
        >>> # Nodes in different contexts can't be mixed.
        >>> # However, we can translate nodes from one context to another.
        >>> x.translate(c2) + y
        x + y
        """
        ...

    def __copy__(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def hash(self):  # -> Any:
        """Return a hashcode for the `self`.

        >>> n1 = simplify(Int('x') + 1)
        >>> n2 = simplify(2 + Int('x') - 1)
        >>> n1.hash() == n2.hash()
        True
        """
        ...

def is_ast(a):  # -> bool:
    """Return `True` if `a` is an AST node.

    >>> is_ast(10)
    False
    >>> is_ast(IntVal(10))
    True
    >>> is_ast(Int('x'))
    True
    >>> is_ast(BoolSort())
    True
    >>> is_ast(Function('f', IntSort(), IntSort()))
    True
    >>> is_ast("x")
    False
    >>> is_ast(Solver())
    False
    """
    ...

def eq(a, b):
    """Return `True` if `a` and `b` are structurally identical AST nodes.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> eq(x, y)
    False
    >>> eq(x + 1, x + 1)
    True
    >>> eq(x + 1, 1 + x)
    False
    >>> eq(simplify(x + 1), simplify(1 + x))
    True
    """
    ...

class SortRef(AstRef):
    """A Sort is essentially a type. Every Z3 expression has a sort. A sort is an AST node."""
    def as_ast(self):  # -> Any:
        ...
    def get_id(self):  # -> Any:
        ...
    def kind(self):  # -> Any:
        """Return the Z3 internal kind of a sort.
        This method can be used to test if `self` is one of the Z3 builtin sorts.

        >>> b = BoolSort()
        >>> b.kind() == Z3_BOOL_SORT
        True
        >>> b.kind() == Z3_INT_SORT
        False
        >>> A = ArraySort(IntSort(), IntSort())
        >>> A.kind() == Z3_ARRAY_SORT
        True
        >>> A.kind() == Z3_INT_SORT
        False
        """
        ...

    def __setattr__(self, name: str, value: Any) -> None: ...
    def subsort(self, other):  # -> Literal[False]:
        """Return `True` if `self` is a subsort of `other`.

        >>> IntSort().subsort(RealSort())
        True
        """
        ...

    def cast(self, val):
        """Try to cast `val` as an element of sort `self`.

        This method is used in Z3Py to convert Python objects such as integers,
        floats, longs and strings into Z3 expressions.

        >>> x = Int('x')
        >>> RealSort().cast(x)
        ToReal(x)
        """
        ...

    def name(self):  # -> Any | Literal['']:
        """Return the name (string) of sort `self`.

        >>> BoolSort().name()
        'Bool'
        >>> ArraySort(IntSort(), IntSort()).name()
        'Array'
        """
        ...

    def __eq__(self, other) -> bool:
        """Return `True` if `self` and `other` are the same Z3 sort.

        >>> p = Bool('p')
        >>> p.sort() == BoolSort()
        True
        >>> p.sort() == IntSort()
        False
        """
        ...

    def __ne__(self, other) -> bool:
        """Return `True` if `self` and `other` are not the same Z3 sort.

        >>> p = Bool('p')
        >>> p.sort() != BoolSort()
        False
        >>> p.sort() != IntSort()
        True
        """
        ...

    def __hash__(self) -> int:
        """Hash code."""
        ...

def is_sort(s):  # -> bool:
    """Return `True` if `s` is a Z3 sort.

    >>> is_sort(IntSort())
    True
    >>> is_sort(Int('x'))
    False
    >>> is_expr(Int('x'))
    True
    """
    ...

def DeclareSort(name, ctx=...):  # -> SortRef:
    """Create a new uninterpreted sort named `name`.

    If `ctx=None`, then the new sort is declared in the global Z3Py context.

    >>> A = DeclareSort('A')
    >>> a = Const('a', A)
    >>> b = Const('b', A)
    >>> a.sort() == A
    True
    >>> b.sort() == A
    True
    >>> a == b
    a == b
    """
    ...

class TypeVarRef(SortRef):
    """Type variable reference"""
    def subsort(self, other):  # -> Literal[True]:
        ...
    def cast(self, val): ...

def DeclareTypeVar(name, ctx=...):  # -> TypeVarRef:
    """Create a new type variable named `name`.

    If `ctx=None`, then the new sort is declared in the global Z3Py context.

    """
    ...

class FuncDeclRef(AstRef):
    """Function declaration. Every constant and function have an associated declaration.

    The declaration assigns a name, a sort (i.e., type), and for function
    the sort (i.e., type) of each of its arguments. Note that, in Z3,
    a constant is a function with 0 arguments.
    """

    defn = ...
    def as_ast(self):  # -> Any:
        ...
    def get_id(self):  # -> Any:
        ...
    def as_func_decl(self):  # -> Any | None:
        ...
    def name(self):  # -> Any | Literal['']:
        """Return the name of the function declaration `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> f.name()
        'f'
        >>> isinstance(f.name(), str)
        True
        """
        ...

    def arity(self):  # -> int:
        """Return the number of arguments of a function declaration.
        If `self` is a constant, then `self.arity()` is 0.

        >>> f = Function('f', IntSort(), RealSort(), BoolSort())
        >>> f.arity()
        2
        """
        ...

    def domain(
        self, i
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the sort of the argument `i` of a function declaration.
        This method assumes that `0 <= i < self.arity()`.

        >>> f = Function('f', IntSort(), RealSort(), BoolSort())
        >>> f.domain(0)
        Int
        >>> f.domain(1)
        Real
        """
        ...

    def range(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the sort of the range of a function declaration.
        For constants, this is the sort of the constant.

        >>> f = Function('f', IntSort(), RealSort(), BoolSort())
        >>> f.range()
        Bool
        """
        ...

    def kind(self):  # -> Any:
        """Return the internal kind of a function declaration.
        It can be used to identify Z3 built-in functions such as addition, multiplication, etc.

        >>> x = Int('x')
        >>> d = (x + 1).decl()
        >>> d.kind() == Z3_OP_ADD
        True
        >>> d.kind() == Z3_OP_MUL
        False
        """
        ...

    def params(self):  # -> list[None]:
        ...
    def __call__(
        self, *args
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Create a Z3 application expression using the function `self`, and the given arguments.

        The arguments must be Z3 expressions. This method assumes that
        the sorts of the elements in `args` match the sorts of the
        domain. Limited coercion is supported.  For example, if
        args[0] is a Python integer, and the function expects a Z3
        integer, then the argument is automatically converted into a
        Z3 integer.

        >>> f = Function('f', IntSort(), RealSort(), BoolSort())
        >>> x = Int('x')
        >>> y = Real('y')
        >>> f(x, y)
        f(x, y)
        >>> f(x, x)
        f(x, ToReal(x))
        """
        ...

def is_func_decl(a):  # -> bool:
    """Return `True` if `a` is a Z3 function declaration.

    >>> f = Function('f', IntSort(), IntSort())
    >>> is_func_decl(f)
    True
    >>> x = Real('x')
    >>> is_func_decl(x)
    False
    """
    ...

def Function(name, *sig):  # -> FuncDeclRef:
    """Create a new Z3 uninterpreted function with the given sorts.

    >>> f = Function('f', IntSort(), IntSort())
    >>> f(f(0))
    f(f(0))
    """
    ...

def FreshFunction(*sig):  # -> FuncDeclRef:
    """Create a new fresh Z3 uninterpreted function with the given sorts."""
    ...

def RecFunction(name, *sig):  # -> FuncDeclRef:
    """Create a new Z3 recursive with the given sorts."""
    ...

def RecAddDefinition(f, args, body):  # -> None:
    """Set the body of a recursive function.
       Recursive definitions can be simplified if they are applied to ground
       arguments.
    >>> ctx = Context()
    >>> fac = RecFunction('fac', IntSort(ctx), IntSort(ctx))
    >>> n = Int('n', ctx)
    >>> RecAddDefinition(fac, n, If(n == 0, 1, n*fac(n-1)))
    >>> simplify(fac(5))
    120
    >>> s = Solver(ctx=ctx)
    >>> s.add(fac(n) < 3)
    >>> s.check()
    sat
    >>> s.model().eval(fac(5))
    120
    """
    ...

class ExprRef(AstRef):
    """Constraints, formulas and terms are expressions in Z3.

    Expressions are ASTs. Every expression has a sort.
    There are three main kinds of expressions:
    function applications, quantifiers and bounded variables.
    A constant is a function application with 0 arguments.
    For quantifier free problems, all expressions are
    function applications.
    """

    defn = ...
    wf = ...
    rel = ...
    induct = ...

    def as_ast(self):  # -> Any | None:
        ...
    def get_id(self):  # -> Any:
        ...
    def sort(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the sort of expression `self`.

        >>> x = Int('x')
        >>> (x + 1).sort()
        Int
        >>> y = Real('y')
        >>> (x + y).sort()
        Real
        """
        ...

    def sort_kind(self):  # -> Any:
        """Shorthand for `self.sort().kind()`.

        >>> a = Array('a', IntSort(), IntSort())
        >>> a.sort_kind() == Z3_ARRAY_SORT
        True
        >>> a.sort_kind() == Z3_INT_SORT
        False
        """
        ...

    def __eq__(self, other) -> bool:
        """Return a Z3 expression that represents the constraint `self == other`.

        If `other` is `None`, then this method simply returns `False`.

        >>> a = Int('a')
        >>> b = Int('b')
        >>> a == b
        a == b
        >>> a is None
        False
        """
        ...

    def __hash__(self) -> int:
        """Hash code."""
        ...

    def __ne__(self, other) -> bool:
        """Return a Z3 expression that represents the constraint `self != other`.

        If `other` is `None`, then this method simply returns `True`.

        >>> a = Int('a')
        >>> b = Int('b')
        >>> a != b
        a != b
        >>> a is not None
        True
        """
        ...

    def params(self):  # -> list[None]:
        ...
    def decl(self):  # -> FuncDeclRef:
        """Return the Z3 function declaration associated with a Z3 application.

        >>> f = Function('f', IntSort(), IntSort())
        >>> a = Int('a')
        >>> t = f(a)
        >>> eq(t.decl(), f)
        True
        >>> (a + 1).decl()
        +
        """
        ...

    def kind(self):  # -> Any:
        """Return the Z3 internal kind of a function application."""
        ...

    def num_args(self):  # -> int:
        """Return the number of arguments of a Z3 application.

        >>> a = Int('a')
        >>> b = Int('b')
        >>> (a + b).num_args()
        2
        >>> f = Function('f', IntSort(), IntSort(), IntSort(), IntSort())
        >>> t = f(a, b, 0)
        >>> t.num_args()
        3
        """
        ...

    def arg(
        self, idx
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return argument `idx` of the application `self`.

        This method assumes that `self` is a function application with at least `idx+1` arguments.

        >>> a = Int('a')
        >>> b = Int('b')
        >>> f = Function('f', IntSort(), IntSort(), IntSort(), IntSort())
        >>> t = f(a, b, 0)
        >>> t.arg(0)
        a
        >>> t.arg(1)
        b
        >>> t.arg(2)
        0
        """
        ...

    def children(
        self,
    ):  # -> list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef] | list[Any]:
        """Return a list containing the children of the given expression

        >>> a = Int('a')
        >>> b = Int('b')
        >>> f = Function('f', IntSort(), IntSort(), IntSort(), IntSort())
        >>> t = f(a, b, 0)
        >>> t.children()
        [a, b, 0]
        """
        ...

    def from_string(self, s):  # -> None:
        ...
    def serialize(self):  # -> Any | Literal['']:
        ...

def deserialize(
    st,
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """inverse function to the serialize method on ExprRef.
    It is made available to make it easier for users to serialize expressions back and forth between
    strings. Solvers can be serialized using the 'sexpr()' method.
    """
    ...

def is_expr(a):  # -> bool:
    """Return `True` if `a` is a Z3 expression.

    >>> a = Int('a')
    >>> is_expr(a)
    True
    >>> is_expr(a + 1)
    True
    >>> is_expr(IntSort())
    False
    >>> is_expr(1)
    False
    >>> is_expr(IntVal(1))
    True
    >>> x = Int('x')
    >>> is_expr(ForAll(x, x >= 0))
    True
    >>> is_expr(FPVal(1.0))
    True
    """
    ...

def is_app(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 function application.

    Note that, constants are function applications with 0 arguments.

    >>> a = Int('a')
    >>> is_app(a)
    True
    >>> is_app(a + 1)
    True
    >>> is_app(IntSort())
    False
    >>> is_app(1)
    False
    >>> is_app(IntVal(1))
    True
    >>> x = Int('x')
    >>> is_app(ForAll(x, x >= 0))
    False
    """
    ...

def is_const(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is Z3 constant/variable expression.

    >>> a = Int('a')
    >>> is_const(a)
    True
    >>> is_const(a + 1)
    False
    >>> is_const(1)
    False
    >>> is_const(IntVal(1))
    True
    >>> x = Int('x')
    >>> is_const(ForAll(x, x >= 0))
    False
    """
    ...

def is_var(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is variable.

    Z3 uses de-Bruijn indices for representing bound variables in
    quantifiers.

    >>> x = Int('x')
    >>> is_var(x)
    False
    >>> is_const(x)
    True
    >>> f = Function('f', IntSort(), IntSort())
    >>> # Z3 replaces x with bound variables when ForAll is executed.
    >>> q = ForAll(x, f(x) == x)
    >>> b = q.body()
    >>> b
    f(Var(0)) == Var(0)
    >>> b.arg(1)
    Var(0)
    >>> is_var(b.arg(1))
    True
    """
    ...

def get_var_index(a):  # -> int:
    """Return the de-Bruijn index of the Z3 bounded variable `a`.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> is_var(x)
    False
    >>> is_const(x)
    True
    >>> f = Function('f', IntSort(), IntSort(), IntSort())
    >>> # Z3 replaces x and y with bound variables when ForAll is executed.
    >>> q = ForAll([x, y], f(x, y) == x + y)
    >>> q.body()
    f(Var(1), Var(0)) == Var(1) + Var(0)
    >>> b = q.body()
    >>> b.arg(0)
    f(Var(1), Var(0))
    >>> v1 = b.arg(0).arg(0)
    >>> v2 = b.arg(0).arg(1)
    >>> v1
    Var(1)
    >>> v2
    Var(0)
    >>> get_var_index(v1)
    1
    >>> get_var_index(v2)
    0
    """
    ...

def is_app_of(a, k):  # -> Any | Literal[False]:
    """Return `True` if `a` is an application of the given kind `k`.

    >>> x = Int('x')
    >>> n = x + 1
    >>> is_app_of(n, Z3_OP_ADD)
    True
    >>> is_app_of(n, Z3_OP_MUL)
    False
    """
    ...

def If(
    a, b, c, ctx=...
):  # -> Tactic | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Create a Z3 if-then-else expression.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> max = If(x > y, x, y)
    >>> max
    If(x > y, x, y)
    >>> simplify(max)
    If(x <= y, y, x)
    """
    ...

def Distinct(*args):  # -> BoolRef:
    """Create a Z3 distinct expression.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> Distinct(x, y)
    x != y
    >>> z = Int('z')
    >>> Distinct(x, y, z)
    Distinct(x, y, z)
    >>> simplify(Distinct(x, y, z))
    Distinct(x, y, z)
    >>> simplify(Distinct(x, y, z), blast_distinct=True)
    And(Not(x == y), Not(x == z), Not(y == z))
    """
    ...

def Const(
    name, sort
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Create a constant of the given sort.

    >>> Const('x', IntSort())
    x
    """
    ...

def Consts(
    names, sort
):  # -> list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef]:
    """Create several constants of the given sort.

    `names` is a string containing the names of all constants to be created.
    Blank spaces separate the names of different constants.

    >>> x, y, z = Consts('x y z', IntSort())
    >>> x + y + z
    x + y + z
    """
    ...

def FreshConst(
    sort, prefix=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Create a fresh constant of a specified sort"""
    ...

def Var(
    idx, s
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Create a Z3 free variable. Free variables are used to create quantified formulas.
    A free variable with index n is bound when it occurs within the scope of n+1 quantified
    declarations.

    >>> Var(0, IntSort())
    Var(0)
    >>> eq(Var(0, IntSort()), Var(0, BoolSort()))
    False
    """
    ...

def RealVar(
    idx, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """
    Create a real free variable. Free variables are used to create quantified formulas.
    They are also used to create polynomials.

    >>> RealVar(0)
    Var(0)
    """
    ...

def RealVarVector(
    n, ctx=...
):  # -> list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef]:
    """
    Create a list of Real free variables.
    The variables have ids: 0, 1, ..., n-1

    >>> x0, x1, x2, x3 = RealVarVector(4)
    >>> x2
    Var(2)
    """
    ...

class BoolSortRef(SortRef):
    """Boolean sort."""
    def cast(self, val):  # -> BoolRef:
        """Try to cast `val` as a Boolean.

        >>> x = BoolSort().cast(True)
        >>> x
        True
        >>> is_expr(x)
        True
        >>> is_expr(True)
        False
        >>> x.sort()
        Bool
        """
        ...

    def subsort(self, other):  # -> bool:
        ...
    def is_int(self):  # -> Literal[True]:
        ...
    def is_bool(self):  # -> Literal[True]:
        ...

class BoolRef(ExprRef):
    """All Boolean expressions are instances of this class."""
    def sort(self):  # -> BoolSortRef:
        ...
    def __add__(self, other):  # -> ArithRef | BitVecRef | FPRef | SeqRef | ReRef:
        ...
    def __radd__(self, other): ...
    def __rmul__(self, other): ...
    def __mul__(
        self, other
    ):  # -> Tactic | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Create the Z3 expression `self * other`."""
        ...

    def __and__(self, other):  # -> Probe | BoolRef:
        ...
    def __or__(self, other):  # -> Probe | BoolRef:
        ...
    def __xor__(self, other):  # -> BoolRef:
        ...
    def __invert__(self):  # -> Probe | BoolRef:
        ...

def is_bool(a):  # -> bool:
    """Return `True` if `a` is a Z3 Boolean expression.

    >>> p = Bool('p')
    >>> is_bool(p)
    True
    >>> q = Bool('q')
    >>> is_bool(And(p, q))
    True
    >>> x = Real('x')
    >>> is_bool(x)
    False
    >>> is_bool(x == 0)
    True
    """
    ...

def is_true(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is the Z3 true expression.

    >>> p = Bool('p')
    >>> is_true(p)
    False
    >>> is_true(simplify(p == p))
    True
    >>> x = Real('x')
    >>> is_true(x == 0)
    False
    >>> # True is a Python Boolean expression
    >>> is_true(True)
    False
    """
    ...

def is_false(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is the Z3 false expression.

    >>> p = Bool('p')
    >>> is_false(p)
    False
    >>> is_false(False)
    False
    >>> is_false(BoolVal(False))
    True
    """
    ...

def is_and(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 and expression.

    >>> p, q = Bools('p q')
    >>> is_and(And(p, q))
    True
    >>> is_and(Or(p, q))
    False
    """
    ...

def is_or(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 or expression.

    >>> p, q = Bools('p q')
    >>> is_or(Or(p, q))
    True
    >>> is_or(And(p, q))
    False
    """
    ...

def is_implies(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 implication expression.

    >>> p, q = Bools('p q')
    >>> is_implies(Implies(p, q))
    True
    >>> is_implies(And(p, q))
    False
    """
    ...

def is_not(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 not expression.

    >>> p = Bool('p')
    >>> is_not(p)
    False
    >>> is_not(Not(p))
    True
    """
    ...

def is_eq(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 equality expression.

    >>> x, y = Ints('x y')
    >>> is_eq(x == y)
    True
    """
    ...

def is_distinct(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 distinct expression.

    >>> x, y, z = Ints('x y z')
    >>> is_distinct(x == y)
    False
    >>> is_distinct(Distinct(x, y, z))
    True
    """
    ...

def BoolSort(ctx=...):  # -> BoolSortRef:
    """Return the Boolean Z3 sort. If `ctx=None`, then the global context is used.

    >>> BoolSort()
    Bool
    >>> p = Const('p', BoolSort())
    >>> is_bool(p)
    True
    >>> r = Function('r', IntSort(), IntSort(), BoolSort())
    >>> r(0, 1)
    r(0, 1)
    >>> is_bool(r(0, 1))
    True
    """
    ...

def BoolVal(val, ctx=...):  # -> BoolRef:
    """Return the Boolean value `True` or `False`. If `ctx=None`, then the global context is used.

    >>> BoolVal(True)
    True
    >>> is_true(BoolVal(True))
    True
    >>> is_true(True)
    False
    >>> is_false(BoolVal(False))
    True
    """
    ...

def Bool(name, ctx=...):  # -> BoolRef:
    """Return a Boolean constant named `name`. If `ctx=None`, then the global context is used.

    >>> p = Bool('p')
    >>> q = Bool('q')
    >>> And(p, q)
    And(p, q)
    """
    ...

def Bools(names, ctx=...):  # -> list[BoolRef]:
    """Return a tuple of Boolean constants.

    `names` is a single string containing all names separated by blank spaces.
    If `ctx=None`, then the global context is used.

    >>> p, q, r = Bools('p q r')
    >>> And(p, Or(q, r))
    And(p, Or(q, r))
    """
    ...

def BoolVector(prefix, sz, ctx=...):  # -> list[BoolRef]:
    """Return a list of Boolean constants of size `sz`.

    The constants are named using the given prefix.
    If `ctx=None`, then the global context is used.

    >>> P = BoolVector('p', 3)
    >>> P
    [p__0, p__1, p__2]
    >>> And(P)
    And(p__0, p__1, p__2)
    """
    ...

def FreshBool(prefix=..., ctx=...):  # -> BoolRef:
    """Return a fresh Boolean constant in the given context using the given prefix.

    If `ctx=None`, then the global context is used.

    >>> b1 = FreshBool()
    >>> b2 = FreshBool()
    >>> eq(b1, b2)
    False
    """
    ...

def Implies(a, b, ctx=...):  # -> BoolRef:
    """Create a Z3 implies expression.

    >>> p, q = Bools('p q')
    >>> Implies(p, q)
    Implies(p, q)
    """
    ...

def Xor(a, b, ctx=...):  # -> BoolRef:
    """Create a Z3 Xor expression.

    >>> p, q = Bools('p q')
    >>> Xor(p, q)
    Xor(p, q)
    >>> simplify(Xor(p, q))
    Not(p == q)
    """
    ...

def Not(a, ctx=...):  # -> Probe | BoolRef:
    """Create a Z3 not expression or probe.

    >>> p = Bool('p')
    >>> Not(Not(p))
    Not(Not(p))
    >>> simplify(Not(Not(p)))
    p
    """
    ...

def mk_not(a):  # -> Probe | BoolRef:
    ...
def And(*args):  # -> Probe | BoolRef:
    """Create a Z3 and-expression or and-probe.

    >>> p, q, r = Bools('p q r')
    >>> And(p, q, r)
    And(p, q, r)
    >>> P = BoolVector('p', 5)
    >>> And(P)
    And(p__0, p__1, p__2, p__3, p__4)
    """
    ...

def Or(*args):  # -> Probe | BoolRef:
    """Create a Z3 or-expression or or-probe.

    >>> p, q, r = Bools('p q r')
    >>> Or(p, q, r)
    Or(p, q, r)
    >>> P = BoolVector('p', 5)
    >>> Or(P)
    Or(p__0, p__1, p__2, p__3, p__4)
    """
    ...

class PatternRef(ExprRef):
    """Patterns are hints for quantifier instantiation."""
    def as_ast(self):  # -> Any:
        ...
    def get_id(self):  # -> Any:
        ...

def is_pattern(a):  # -> bool:
    """Return `True` if `a` is a Z3 pattern (hint for quantifier instantiation.

    >>> f = Function('f', IntSort(), IntSort())
    >>> x = Int('x')
    >>> q = ForAll(x, f(x) == 0, patterns = [ f(x) ])
    >>> q
    ForAll(x, f(x) == 0)
    >>> q.num_patterns()
    1
    >>> is_pattern(q.pattern(0))
    True
    >>> q.pattern(0)
    f(Var(0))
    """
    ...

def MultiPattern(*args):  # -> PatternRef:
    """Create a Z3 multi-pattern using the given expressions `*args`

    >>> f = Function('f', IntSort(), IntSort())
    >>> g = Function('g', IntSort(), IntSort())
    >>> x = Int('x')
    >>> q = ForAll(x, f(x) != g(x), patterns = [ MultiPattern(f(x), g(x)) ])
    >>> q
    ForAll(x, f(x) != g(x))
    >>> q.num_patterns()
    1
    >>> is_pattern(q.pattern(0))
    True
    >>> q.pattern(0)
    MultiPattern(f(Var(0)), g(Var(0)))
    """
    ...

class QuantifierRef(BoolRef):
    """Universally and Existentially quantified formulas."""
    def __call__(self, *args: ExprRef) -> ExprRef: ...
    def as_ast(self):  # -> Any | None:
        ...
    def get_id(self):  # -> Any:
        ...
    def sort(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the Boolean sort or sort of Lambda."""
        ...

    def is_forall(self):  # -> Any:
        """Return `True` if `self` is a universal quantifier.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) == 0)
        >>> q.is_forall()
        True
        >>> q = Exists(x, f(x) != 0)
        >>> q.is_forall()
        False
        """
        ...

    def is_exists(self):  # -> Any:
        """Return `True` if `self` is an existential quantifier.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) == 0)
        >>> q.is_exists()
        False
        >>> q = Exists(x, f(x) != 0)
        >>> q.is_exists()
        True
        """
        ...

    def is_lambda(self):  # -> Any:
        """Return `True` if `self` is a lambda expression.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = Lambda(x, f(x))
        >>> q.is_lambda()
        True
        >>> q = Exists(x, f(x) != 0)
        >>> q.is_lambda()
        False
        """
        ...

    def __getitem__(
        self, arg
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return the Z3 expression `self[arg]`."""
        ...

    def weight(self):  # -> int:
        """Return the weight annotation of `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) == 0)
        >>> q.weight()
        1
        >>> q = ForAll(x, f(x) == 0, weight=10)
        >>> q.weight()
        10
        """
        ...

    def skolem_id(self):  # -> Any | Literal['']:
        """Return the skolem id of `self`."""
        ...

    def qid(self):  # -> Any | Literal['']:
        """Return the quantifier id of `self`."""
        ...

    def num_patterns(self):  # -> int:
        """Return the number of patterns (i.e., quantifier instantiation hints) in `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> g = Function('g', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) != g(x), patterns = [ f(x), g(x) ])
        >>> q.num_patterns()
        2
        """
        ...

    def pattern(self, idx):  # -> PatternRef:
        """Return a pattern (i.e., quantifier instantiation hints) in `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> g = Function('g', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) != g(x), patterns = [ f(x), g(x) ])
        >>> q.num_patterns()
        2
        >>> q.pattern(0)
        f(Var(0))
        >>> q.pattern(1)
        g(Var(0))
        """
        ...

    def num_no_patterns(self):  # -> Any:
        """Return the number of no-patterns."""
        ...

    def no_pattern(
        self, idx
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return a no-pattern."""
        ...

    def body(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return the expression being quantified.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) == 0)
        >>> q.body()
        f(Var(0)) == 0
        """
        ...

    def num_vars(self):  # -> int:
        """Return the number of variables bounded by this quantifier.

        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> x = Int('x')
        >>> y = Int('y')
        >>> q = ForAll([x, y], f(x, y) >= x)
        >>> q.num_vars()
        2
        """
        ...

    def var_name(self, idx):  # -> Any | Literal['']:
        """Return a string representing a name used when displaying the quantifier.

        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> x = Int('x')
        >>> y = Int('y')
        >>> q = ForAll([x, y], f(x, y) >= x)
        >>> q.var_name(0)
        'x'
        >>> q.var_name(1)
        'y'
        """
        ...

    def var_sort(
        self, idx
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the sort of a bound variable.

        >>> f = Function('f', IntSort(), RealSort(), IntSort())
        >>> x = Int('x')
        >>> y = Real('y')
        >>> q = ForAll([x, y], f(x, y) >= x)
        >>> q.var_sort(0)
        Int
        >>> q.var_sort(1)
        Real
        """
        ...

    def children(
        self,
    ):  # -> list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef]:
        """Return a list containing a single element self.body()

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> q = ForAll(x, f(x) == 0)
        >>> q.children()
        [f(Var(0)) == 0]
        """
        ...

def is_quantifier(a):  # -> bool:
    """Return `True` if `a` is a Z3 quantifier.

    >>> f = Function('f', IntSort(), IntSort())
    >>> x = Int('x')
    >>> q = ForAll(x, f(x) == 0)
    >>> is_quantifier(q)
    True
    >>> is_quantifier(f(x))
    False
    """
    ...

def ForAll(
    vs, body, weight=..., qid=..., skid=..., patterns=..., no_patterns=...
):  # -> BoolRef | QuantifierRef:
    """Create a Z3 forall formula.

    The parameters `weight`, `qid`, `skid`, `patterns` and `no_patterns` are optional annotations.

    >>> f = Function('f', IntSort(), IntSort(), IntSort())
    >>> x = Int('x')
    >>> y = Int('y')
    >>> ForAll([x, y], f(x, y) >= x)
    ForAll([x, y], f(x, y) >= x)
    >>> ForAll([x, y], f(x, y) >= x, patterns=[ f(x, y) ])
    ForAll([x, y], f(x, y) >= x)
    >>> ForAll([x, y], f(x, y) >= x, weight=10)
    ForAll([x, y], f(x, y) >= x)
    """
    ...

def Exists(
    vs, body, weight=..., qid=..., skid=..., patterns=..., no_patterns=...
):  # -> BoolRef | QuantifierRef:
    """Create a Z3 exists formula.

    The parameters `weight`, `qif`, `skid`, `patterns` and `no_patterns` are optional annotations.


    >>> f = Function('f', IntSort(), IntSort(), IntSort())
    >>> x = Int('x')
    >>> y = Int('y')
    >>> q = Exists([x, y], f(x, y) >= x, skid="foo")
    >>> q
    Exists([x, y], f(x, y) >= x)
    >>> is_quantifier(q)
    True
    >>> r = Tactic('nnf')(q).as_expr()
    >>> is_quantifier(r)
    False
    """
    ...

def Lambda(vs, body):  # -> QuantifierRef:
    """Create a Z3 lambda expression.

    >>> f = Function('f', IntSort(), IntSort(), IntSort())
    >>> mem0 = Array('mem0', IntSort(), IntSort())
    >>> lo, hi, e, i = Ints('lo hi e i')
    >>> mem1 = Lambda([i], If(And(lo <= i, i <= hi), e, mem0[i]))
    >>> mem1
    Lambda(i, If(And(lo <= i, i <= hi), e, mem0[i]))
    """
    ...

class ArithSortRef(SortRef):
    """Real and Integer sorts."""
    def is_real(self):  # -> Any:
        """Return `True` if `self` is of the sort Real.

        >>> x = Real('x')
        >>> x.is_real()
        True
        >>> (x + 1).is_real()
        True
        >>> x = Int('x')
        >>> x.is_real()
        False
        """
        ...

    def is_int(self):  # -> Any:
        """Return `True` if `self` is of the sort Integer.

        >>> x = Int('x')
        >>> x.is_int()
        True
        >>> (x + 1).is_int()
        True
        >>> x = Real('x')
        >>> x.is_int()
        False
        """
        ...

    def is_bool(self):  # -> Literal[False]:
        ...
    def subsort(self, other):  # -> Any | Literal[False]:
        """Return `True` if `self` is a subsort of `other`."""
        ...

    def cast(
        self, val
    ):  # -> ArithRef | Tactic | PatternRef | QuantifierRef | BoolRef | IntNumRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | None:
        """Try to cast `val` as an Integer or Real.

        >>> IntSort().cast(10)
        10
        >>> is_int(IntSort().cast(10))
        True
        >>> is_int(10)
        False
        >>> RealSort().cast(10)
        10
        >>> is_real(RealSort().cast(10))
        True
        """
        ...

def is_arith_sort(s):  # -> bool:
    """Return `True` if s is an arithmetical sort (type).

    >>> is_arith_sort(IntSort())
    True
    >>> is_arith_sort(RealSort())
    True
    >>> is_arith_sort(BoolSort())
    False
    >>> n = Int('x') + 1
    >>> is_arith_sort(n.sort())
    True
    """
    ...

class ArithRef(ExprRef):
    """Integer and Real expressions."""
    def sort(self):  # -> ArithSortRef:
        """Return the sort (type) of the arithmetical expression `self`.

        >>> Int('x').sort()
        Int
        >>> (Real('x') + 1).sort()
        Real
        """
        ...

    def is_int(self):  # -> Any:
        """Return `True` if `self` is an integer expression.

        >>> x = Int('x')
        >>> x.is_int()
        True
        >>> (x + 1).is_int()
        True
        >>> y = Real('y')
        >>> (x + y).is_int()
        False
        """
        ...

    def is_real(self):  # -> Any:
        """Return `True` if `self` is an real expression.

        >>> x = Real('x')
        >>> x.is_real()
        True
        >>> (x + 1).is_real()
        True
        """
        ...

    def __add__(self, other):  # -> ArithRef:
        """Create the Z3 expression `self + other`.

        >>> x = Int('x')
        >>> y = Int('y')
        >>> x + y
        x + y
        >>> (x + y).sort()
        Int
        """
        ...

    def __radd__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other + self`.

        >>> x = Int('x')
        >>> 10 + x
        10 + x
        """
        ...

    def __mul__(
        self, other
    ):  # -> Tactic | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Create the Z3 expression `self * other`.

        >>> x = Real('x')
        >>> y = Real('y')
        >>> x * y
        x*y
        >>> (x * y).sort()
        Real
        """
        ...

    def __rmul__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other * self`.

        >>> x = Real('x')
        >>> 10 * x
        10*x
        """
        ...

    def __sub__(self, other):  # -> ArithRef:
        """Create the Z3 expression `self - other`.

        >>> x = Int('x')
        >>> y = Int('y')
        >>> x - y
        x - y
        >>> (x - y).sort()
        Int
        """
        ...

    def __rsub__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other - self`.

        >>> x = Int('x')
        >>> 10 - x
        10 - x
        """
        ...

    def __pow__(self, other):  # -> ArithRef:
        """Create the Z3 expression `self**other` (** is the power operator).

        >>> x = Real('x')
        >>> x**3
        x**3
        >>> (x**3).sort()
        Real
        >>> simplify(IntVal(2)**8)
        256
        """
        ...

    def __rpow__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other**self` (** is the power operator).

        >>> x = Real('x')
        >>> 2**x
        2**x
        >>> (2**x).sort()
        Real
        >>> simplify(2**IntVal(8))
        256
        """
        ...

    def __div__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other/self`.

        >>> x = Int('x')
        >>> y = Int('y')
        >>> x/y
        x/y
        >>> (x/y).sort()
        Int
        >>> (x/y).sexpr()
        '(div x y)'
        >>> x = Real('x')
        >>> y = Real('y')
        >>> x/y
        x/y
        >>> (x/y).sort()
        Real
        >>> (x/y).sexpr()
        '(/ x y)'
        """
        ...

    def __truediv__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other/self`."""
        ...

    def __rdiv__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other/self`.

        >>> x = Int('x')
        >>> 10/x
        10/x
        >>> (10/x).sexpr()
        '(div 10 x)'
        >>> x = Real('x')
        >>> 10/x
        10/x
        >>> (10/x).sexpr()
        '(/ 10.0 x)'
        """
        ...

    def __rtruediv__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other/self`."""
        ...

    def __mod__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other%self`.

        >>> x = Int('x')
        >>> y = Int('y')
        >>> x % y
        x%y
        >>> simplify(IntVal(10) % IntVal(3))
        1
        """
        ...

    def __rmod__(self, other):  # -> ArithRef:
        """Create the Z3 expression `other%self`.

        >>> x = Int('x')
        >>> 10 % x
        10%x
        """
        ...

    def __neg__(self):  # -> ArithRef:
        """Return an expression representing `-self`.

        >>> x = Int('x')
        >>> -x
        -x
        >>> simplify(-(-x))
        x
        """
        ...

    def __pos__(self):  # -> Self:
        """Return `self`.

        >>> x = Int('x')
        >>> +x
        x
        """
        ...

    def __le__(self, other) -> bool:
        """Create the Z3 expression `other <= self`.

        >>> x, y = Ints('x y')
        >>> x <= y
        x <= y
        >>> y = Real('y')
        >>> x <= y
        ToReal(x) <= y
        """
        ...

    def __lt__(self, other) -> bool:
        """Create the Z3 expression `other < self`.

        >>> x, y = Ints('x y')
        >>> x < y
        x < y
        >>> y = Real('y')
        >>> x < y
        ToReal(x) < y
        """
        ...

    def __gt__(self, other) -> bool:
        """Create the Z3 expression `other > self`.

        >>> x, y = Ints('x y')
        >>> x > y
        x > y
        >>> y = Real('y')
        >>> x > y
        ToReal(x) > y
        """
        ...

    def __ge__(self, other) -> bool:
        """Create the Z3 expression `other >= self`.

        >>> x, y = Ints('x y')
        >>> x >= y
        x >= y
        >>> y = Real('y')
        >>> x >= y
        ToReal(x) >= y
        """
        ...

def is_arith(a):  # -> bool:
    """Return `True` if `a` is an arithmetical expression.

    >>> x = Int('x')
    >>> is_arith(x)
    True
    >>> is_arith(x + 1)
    True
    >>> is_arith(1)
    False
    >>> is_arith(IntVal(1))
    True
    >>> y = Real('y')
    >>> is_arith(y)
    True
    >>> is_arith(y + 1)
    True
    """
    ...

def is_int(a):  # -> Literal[False]:
    """Return `True` if `a` is an integer expression.

    >>> x = Int('x')
    >>> is_int(x + 1)
    True
    >>> is_int(1)
    False
    >>> is_int(IntVal(1))
    True
    >>> y = Real('y')
    >>> is_int(y)
    False
    >>> is_int(y + 1)
    False
    """
    ...

def is_real(a):  # -> Literal[False]:
    """Return `True` if `a` is a real expression.

    >>> x = Int('x')
    >>> is_real(x + 1)
    False
    >>> y = Real('y')
    >>> is_real(y)
    True
    >>> is_real(y + 1)
    True
    >>> is_real(1)
    False
    >>> is_real(RealVal(1))
    True
    """
    ...

def is_int_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an integer value of sort Int.

    >>> is_int_value(IntVal(1))
    True
    >>> is_int_value(1)
    False
    >>> is_int_value(Int('x'))
    False
    >>> n = Int('x') + 1
    >>> n
    x + 1
    >>> n.arg(1)
    1
    >>> is_int_value(n.arg(1))
    True
    >>> is_int_value(RealVal("1/3"))
    False
    >>> is_int_value(RealVal(1))
    False
    """
    ...

def is_rational_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is rational value of sort Real.

    >>> is_rational_value(RealVal(1))
    True
    >>> is_rational_value(RealVal("3/5"))
    True
    >>> is_rational_value(IntVal(1))
    False
    >>> is_rational_value(1)
    False
    >>> n = Real('x') + 1
    >>> n.arg(1)
    1
    >>> is_rational_value(n.arg(1))
    True
    >>> is_rational_value(Real('x'))
    False
    """
    ...

def is_algebraic_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an algebraic value of sort Real.

    >>> is_algebraic_value(RealVal("3/5"))
    False
    >>> n = simplify(Sqrt(2))
    >>> n
    1.4142135623?
    >>> is_algebraic_value(n)
    True
    """
    ...

def is_add(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b + c.

    >>> x, y = Ints('x y')
    >>> is_add(x + y)
    True
    >>> is_add(x - y)
    False
    """
    ...

def is_mul(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b * c.

    >>> x, y = Ints('x y')
    >>> is_mul(x * y)
    True
    >>> is_mul(x - y)
    False
    """
    ...

def is_sub(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b - c.

    >>> x, y = Ints('x y')
    >>> is_sub(x - y)
    True
    >>> is_sub(x + y)
    False
    """
    ...

def is_div(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b / c.

    >>> x, y = Reals('x y')
    >>> is_div(x / y)
    True
    >>> is_div(x + y)
    False
    >>> x, y = Ints('x y')
    >>> is_div(x / y)
    False
    >>> is_idiv(x / y)
    True
    """
    ...

def is_idiv(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b div c.

    >>> x, y = Ints('x y')
    >>> is_idiv(x / y)
    True
    >>> is_idiv(x + y)
    False
    """
    ...

def is_mod(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b % c.

    >>> x, y = Ints('x y')
    >>> is_mod(x % y)
    True
    >>> is_mod(x + y)
    False
    """
    ...

def is_le(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b <= c.

    >>> x, y = Ints('x y')
    >>> is_le(x <= y)
    True
    >>> is_le(x < y)
    False
    """
    ...

def is_lt(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b < c.

    >>> x, y = Ints('x y')
    >>> is_lt(x < y)
    True
    >>> is_lt(x == y)
    False
    """
    ...

def is_ge(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b >= c.

    >>> x, y = Ints('x y')
    >>> is_ge(x >= y)
    True
    >>> is_ge(x == y)
    False
    """
    ...

def is_gt(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form b > c.

    >>> x, y = Ints('x y')
    >>> is_gt(x > y)
    True
    >>> is_gt(x == y)
    False
    """
    ...

def is_is_int(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form IsInt(b).

    >>> x = Real('x')
    >>> is_is_int(IsInt(x))
    True
    >>> is_is_int(x)
    False
    """
    ...

def is_to_real(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form ToReal(b).

    >>> x = Int('x')
    >>> n = ToReal(x)
    >>> n
    ToReal(x)
    >>> is_to_real(n)
    True
    >>> is_to_real(x)
    False
    """
    ...

def is_to_int(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is an expression of the form ToInt(b).

    >>> x = Real('x')
    >>> n = ToInt(x)
    >>> n
    ToInt(x)
    >>> is_to_int(n)
    True
    >>> is_to_int(x)
    False
    """
    ...

class IntNumRef(ArithRef):
    """Integer values."""
    def as_long(self):  # -> int:
        """Return a Z3 integer numeral as a Python long (bignum) numeral.

        >>> v = IntVal(1)
        >>> v + 1
        1 + 1
        >>> v.as_long() + 1
        2
        """
        ...

    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 integer numeral as a Python string.
        >>> v = IntVal(100)
        >>> v.as_string()
        '100'
        """
        ...

    def as_binary_string(self):  # -> Any | Literal['']:
        """Return a Z3 integer numeral as a Python binary string.
        >>> v = IntVal(10)
        >>> v.as_binary_string()
        '1010'
        """
        ...

class RatNumRef(ArithRef):
    """Rational values."""
    def numerator(self):  # -> IntNumRef:
        """Return the numerator of a Z3 rational numeral.

        >>> is_rational_value(RealVal("3/5"))
        True
        >>> n = RealVal("3/5")
        >>> n.numerator()
        3
        >>> is_rational_value(Q(3,5))
        True
        >>> Q(3,5).numerator()
        3
        """
        ...

    def denominator(self):  # -> IntNumRef:
        """Return the denominator of a Z3 rational numeral.

        >>> is_rational_value(Q(3,5))
        True
        >>> n = Q(3,5)
        >>> n.denominator()
        5
        """
        ...

    def numerator_as_long(self):  # -> int:
        """Return the numerator as a Python long.

        >>> v = RealVal(10000000000)
        >>> v
        10000000000
        >>> v + 1
        10000000000 + 1
        >>> v.numerator_as_long() + 1 == 10000000001
        True
        """
        ...

    def denominator_as_long(self):  # -> int:
        """Return the denominator as a Python long.

        >>> v = RealVal("1/3")
        >>> v
        1/3
        >>> v.denominator_as_long()
        3
        """
        ...

    def is_int(self):  # -> Literal[False]:
        ...
    def is_real(self):  # -> Literal[True]:
        ...
    def is_int_value(self):  # -> Any | bool:
        ...
    def as_long(self):  # -> int:
        ...
    def as_decimal(self, prec):  # -> Any | Literal['']:
        """Return a Z3 rational value as a string in decimal notation using at most `prec` decimal places.

        >>> v = RealVal("1/5")
        >>> v.as_decimal(3)
        '0.2'
        >>> v = RealVal("1/3")
        >>> v.as_decimal(3)
        '0.333?'
        """
        ...

    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 rational numeral as a Python string.

        >>> v = Q(3,6)
        >>> v.as_string()
        '1/2'
        """
        ...

    def as_fraction(self):  # -> Fraction:
        """Return a Z3 rational as a Python Fraction object.

        >>> v = RealVal("1/5")
        >>> v.as_fraction()
        Fraction(1, 5)
        """
        ...

class AlgebraicNumRef(ArithRef):
    """Algebraic irrational values."""
    def approx(self, precision=...):  # -> RatNumRef:
        """Return a Z3 rational number that approximates the algebraic number `self`.
        The result `r` is such that |r - self| <= 1/10^precision

        >>> x = simplify(Sqrt(2))
        >>> x.approx(20)
        6838717160008073720548335/4835703278458516698824704
        >>> x.approx(5)
        2965821/2097152
        """
        ...

    def as_decimal(self, prec):  # -> Any | Literal['']:
        """Return a string representation of the algebraic number `self` in decimal notation
        using `prec` decimal places.

        >>> x = simplify(Sqrt(2))
        >>> x.as_decimal(10)
        '1.4142135623?'
        >>> x.as_decimal(20)
        '1.41421356237309504880?'
        """
        ...

    def poly(self):  # -> AstVector:
        ...
    def index(self):  # -> Any:
        ...

def IntSort(ctx=...):  # -> ArithSortRef:
    """Return the integer sort in the given context. If `ctx=None`, then the global context is used.

    >>> IntSort()
    Int
    >>> x = Const('x', IntSort())
    >>> is_int(x)
    True
    >>> x.sort() == IntSort()
    True
    >>> x.sort() == BoolSort()
    False
    """
    ...

def RealSort(ctx=...):  # -> ArithSortRef:
    """Return the real sort in the given context. If `ctx=None`, then the global context is used.

    >>> RealSort()
    Real
    >>> x = Const('x', RealSort())
    >>> is_real(x)
    True
    >>> is_int(x)
    False
    >>> x.sort() == RealSort()
    True
    """
    ...

def IntVal(val, ctx=...):  # -> IntNumRef:
    """Return a Z3 integer value. If `ctx=None`, then the global context is used.

    >>> IntVal(1)
    1
    >>> IntVal("100")
    100
    """
    ...

def RealVal(val, ctx=...):  # -> RatNumRef:
    """Return a Z3 real value.

    `val` may be a Python int, long, float or string representing a number in decimal or rational notation.
    If `ctx=None`, then the global context is used.

    >>> RealVal(1)
    1
    >>> RealVal(1).sort()
    Real
    >>> RealVal("3/5")
    3/5
    >>> RealVal("1.5")
    3/2
    """
    ...

def RatVal(
    a, b, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Return a Z3 rational a/b.

    If `ctx=None`, then the global context is used.

    >>> RatVal(3,5)
    3/5
    >>> RatVal(3,5).sort()
    Real
    """
    ...

def Q(
    a, b, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Return a Z3 rational a/b.

    If `ctx=None`, then the global context is used.

    >>> Q(3,5)
    3/5
    >>> Q(3,5).sort()
    Real
    """
    ...

def Int(name, ctx=...):  # -> ArithRef:
    """Return an integer constant named `name`. If `ctx=None`, then the global context is used.

    >>> x = Int('x')
    >>> is_int(x)
    True
    >>> is_int(x + 1)
    True
    """
    ...

def Ints(names, ctx=...):  # -> list[ArithRef]:
    """Return a tuple of Integer constants.

    >>> x, y, z = Ints('x y z')
    >>> Sum(x, y, z)
    x + y + z
    """
    ...

def IntVector(prefix, sz, ctx=...):  # -> list[ArithRef]:
    """Return a list of integer constants of size `sz`.

    >>> X = IntVector('x', 3)
    >>> X
    [x__0, x__1, x__2]
    >>> Sum(X)
    x__0 + x__1 + x__2
    """
    ...

def FreshInt(prefix=..., ctx=...):  # -> ArithRef:
    """Return a fresh integer constant in the given context using the given prefix.

    >>> x = FreshInt()
    >>> y = FreshInt()
    >>> eq(x, y)
    False
    >>> x.sort()
    Int
    """
    ...

def Real(name, ctx=...):  # -> ArithRef:
    """Return a real constant named `name`. If `ctx=None`, then the global context is used.

    >>> x = Real('x')
    >>> is_real(x)
    True
    >>> is_real(x + 1)
    True
    """
    ...

def Reals(names, ctx=...):  # -> list[ArithRef]:
    """Return a tuple of real constants.

    >>> x, y, z = Reals('x y z')
    >>> Sum(x, y, z)
    x + y + z
    >>> Sum(x, y, z).sort()
    Real
    """
    ...

def RealVector(prefix, sz, ctx=...):  # -> list[ArithRef]:
    """Return a list of real constants of size `sz`.

    >>> X = RealVector('x', 3)
    >>> X
    [x__0, x__1, x__2]
    >>> Sum(X)
    x__0 + x__1 + x__2
    >>> Sum(X).sort()
    Real
    """
    ...

def FreshReal(prefix=..., ctx=...):  # -> ArithRef:
    """Return a fresh real constant in the given context using the given prefix.

    >>> x = FreshReal()
    >>> y = FreshReal()
    >>> eq(x, y)
    False
    >>> x.sort()
    Real
    """
    ...

def ToReal(a):  # -> ArithRef:
    """Return the Z3 expression ToReal(a).

    >>> x = Int('x')
    >>> x.sort()
    Int
    >>> n = ToReal(x)
    >>> n
    ToReal(x)
    >>> n.sort()
    Real
    """
    ...

def ToInt(a):  # -> ArithRef:
    """Return the Z3 expression ToInt(a).

    >>> x = Real('x')
    >>> x.sort()
    Real
    >>> n = ToInt(x)
    >>> n
    ToInt(x)
    >>> n.sort()
    Int
    """
    ...

def IsInt(a):  # -> BoolRef:
    """Return the Z3 predicate IsInt(a).

    >>> x = Real('x')
    >>> IsInt(x + "1/2")
    IsInt(x + 1/2)
    >>> solve(IsInt(x + "1/2"), x > 0, x < 1)
    [x = 1/2]
    >>> solve(IsInt(x + "1/2"), x > 0, x < 1, x != "1/2")
    no solution
    """
    ...

def Sqrt(a, ctx=...):  # -> ArithRef:
    """Return a Z3 expression which represents the square root of a.

    >>> x = Real('x')
    >>> Sqrt(x)
    x**(1/2)
    """
    ...

def Cbrt(a, ctx=...):  # -> ArithRef:
    """Return a Z3 expression which represents the cubic root of a.

    >>> x = Real('x')
    >>> Cbrt(x)
    x**(1/3)
    """
    ...

class BitVecSortRef(SortRef):
    """Bit-vector sort."""
    def size(self):  # -> int:
        """Return the size (number of bits) of the bit-vector sort `self`.

        >>> b = BitVecSort(32)
        >>> b.size()
        32
        """
        ...

    def subsort(self, other):  # -> Literal[False]:
        ...
    def cast(self, val):  # -> BitVecNumRef:
        """Try to cast `val` as a Bit-Vector.

        >>> b = BitVecSort(32)
        >>> b.cast(10)
        10
        >>> b.cast(10).sexpr()
        '#x0000000a'
        """
        ...

def is_bv_sort(s):  # -> bool:
    """Return True if `s` is a Z3 bit-vector sort.

    >>> is_bv_sort(BitVecSort(32))
    True
    >>> is_bv_sort(IntSort())
    False
    """
    ...

class BitVecRef(ExprRef):
    """Bit-vector expressions."""
    def sort(self):  # -> BitVecSortRef:
        """Return the sort of the bit-vector expression `self`.

        >>> x = BitVec('x', 32)
        >>> x.sort()
        BitVec(32)
        >>> x.sort() == BitVecSort(32)
        True
        """
        ...

    def size(self):  # -> int:
        """Return the number of bits of the bit-vector expression `self`.

        >>> x = BitVec('x', 32)
        >>> (x + 1).size()
        32
        >>> Concat(x, x).size()
        64
        """
        ...

    def __add__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `self + other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x + y
        x + y
        >>> (x + y).sort()
        BitVec(32)
        """
        ...

    def __radd__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `other + self`.

        >>> x = BitVec('x', 32)
        >>> 10 + x
        10 + x
        """
        ...

    def __mul__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `self * other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x * y
        x*y
        >>> (x * y).sort()
        BitVec(32)
        """
        ...

    def __rmul__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `other * self`.

        >>> x = BitVec('x', 32)
        >>> 10 * x
        10*x
        """
        ...

    def __sub__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `self - other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x - y
        x - y
        >>> (x - y).sort()
        BitVec(32)
        """
        ...

    def __rsub__(self, other):  # -> BitVecRef:
        """Create the Z3 expression `other - self`.

        >>> x = BitVec('x', 32)
        >>> 10 - x
        10 - x
        """
        ...

    def __or__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-or `self | other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x | y
        x | y
        >>> (x | y).sort()
        BitVec(32)
        """
        ...

    def __ror__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-or `other | self`.

        >>> x = BitVec('x', 32)
        >>> 10 | x
        10 | x
        """
        ...

    def __and__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-and `self & other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x & y
        x & y
        >>> (x & y).sort()
        BitVec(32)
        """
        ...

    def __rand__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-or `other & self`.

        >>> x = BitVec('x', 32)
        >>> 10 & x
        10 & x
        """
        ...

    def __xor__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-xor `self ^ other`.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x ^ y
        x ^ y
        >>> (x ^ y).sort()
        BitVec(32)
        """
        ...

    def __rxor__(self, other):  # -> BitVecRef:
        """Create the Z3 expression bitwise-xor `other ^ self`.

        >>> x = BitVec('x', 32)
        >>> 10 ^ x
        10 ^ x
        """
        ...

    def __pos__(self):  # -> Self:
        """Return `self`.

        >>> x = BitVec('x', 32)
        >>> +x
        x
        """
        ...

    def __neg__(self):  # -> BitVecRef:
        """Return an expression representing `-self`.

        >>> x = BitVec('x', 32)
        >>> -x
        -x
        >>> simplify(-(-x))
        x
        """
        ...

    def __invert__(self):  # -> BitVecRef:
        """Create the Z3 expression bitwise-not `~self`.

        >>> x = BitVec('x', 32)
        >>> ~x
        ~x
        >>> simplify(~(~x))
        x
        """
        ...

    def __div__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) division `self / other`.

        Use the function UDiv() for unsigned division.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x / y
        x/y
        >>> (x / y).sort()
        BitVec(32)
        >>> (x / y).sexpr()
        '(bvsdiv x y)'
        >>> UDiv(x, y).sexpr()
        '(bvudiv x y)'
        """
        ...

    def __truediv__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) division `self / other`."""
        ...

    def __rdiv__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) division `other / self`.

        Use the function UDiv() for unsigned division.

        >>> x = BitVec('x', 32)
        >>> 10 / x
        10/x
        >>> (10 / x).sexpr()
        '(bvsdiv #x0000000a x)'
        >>> UDiv(10, x).sexpr()
        '(bvudiv #x0000000a x)'
        """
        ...

    def __rtruediv__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) division `other / self`."""
        ...

    def __mod__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) mod `self % other`.

        Use the function URem() for unsigned remainder, and SRem() for signed remainder.

        >>> x = BitVec('x', 32)
        >>> y = BitVec('y', 32)
        >>> x % y
        x%y
        >>> (x % y).sort()
        BitVec(32)
        >>> (x % y).sexpr()
        '(bvsmod x y)'
        >>> URem(x, y).sexpr()
        '(bvurem x y)'
        >>> SRem(x, y).sexpr()
        '(bvsrem x y)'
        """
        ...

    def __rmod__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (signed) mod `other % self`.

        Use the function URem() for unsigned remainder, and SRem() for signed remainder.

        >>> x = BitVec('x', 32)
        >>> 10 % x
        10%x
        >>> (10 % x).sexpr()
        '(bvsmod #x0000000a x)'
        >>> URem(10, x).sexpr()
        '(bvurem #x0000000a x)'
        >>> SRem(10, x).sexpr()
        '(bvsrem #x0000000a x)'
        """
        ...

    def __le__(self, other) -> bool:
        """Create the Z3 expression (signed) `other <= self`.

        Use the function ULE() for unsigned less than or equal to.

        >>> x, y = BitVecs('x y', 32)
        >>> x <= y
        x <= y
        >>> (x <= y).sexpr()
        '(bvsle x y)'
        >>> ULE(x, y).sexpr()
        '(bvule x y)'
        """
        ...

    def __lt__(self, other) -> bool:
        """Create the Z3 expression (signed) `other < self`.

        Use the function ULT() for unsigned less than.

        >>> x, y = BitVecs('x y', 32)
        >>> x < y
        x < y
        >>> (x < y).sexpr()
        '(bvslt x y)'
        >>> ULT(x, y).sexpr()
        '(bvult x y)'
        """
        ...

    def __gt__(self, other) -> bool:
        """Create the Z3 expression (signed) `other > self`.

        Use the function UGT() for unsigned greater than.

        >>> x, y = BitVecs('x y', 32)
        >>> x > y
        x > y
        >>> (x > y).sexpr()
        '(bvsgt x y)'
        >>> UGT(x, y).sexpr()
        '(bvugt x y)'
        """
        ...

    def __ge__(self, other) -> bool:
        """Create the Z3 expression (signed) `other >= self`.

        Use the function UGE() for unsigned greater than or equal to.

        >>> x, y = BitVecs('x y', 32)
        >>> x >= y
        x >= y
        >>> (x >= y).sexpr()
        '(bvsge x y)'
        >>> UGE(x, y).sexpr()
        '(bvuge x y)'
        """
        ...

    def __rshift__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (arithmetical) right shift `self >> other`

        Use the function LShR() for the right logical shift

        >>> x, y = BitVecs('x y', 32)
        >>> x >> y
        x >> y
        >>> (x >> y).sexpr()
        '(bvashr x y)'
        >>> LShR(x, y).sexpr()
        '(bvlshr x y)'
        >>> BitVecVal(4, 3)
        4
        >>> BitVecVal(4, 3).as_signed_long()
        -4
        >>> simplify(BitVecVal(4, 3) >> 1).as_signed_long()
        -2
        >>> simplify(BitVecVal(4, 3) >> 1)
        6
        >>> simplify(LShR(BitVecVal(4, 3), 1))
        2
        >>> simplify(BitVecVal(2, 3) >> 1)
        1
        >>> simplify(LShR(BitVecVal(2, 3), 1))
        1
        """
        ...

    def __lshift__(self, other):  # -> BitVecRef:
        """Create the Z3 expression left shift `self << other`

        >>> x, y = BitVecs('x y', 32)
        >>> x << y
        x << y
        >>> (x << y).sexpr()
        '(bvshl x y)'
        >>> simplify(BitVecVal(2, 3) << 1)
        4
        """
        ...

    def __rrshift__(self, other):  # -> BitVecRef:
        """Create the Z3 expression (arithmetical) right shift `other` >> `self`.

        Use the function LShR() for the right logical shift

        >>> x = BitVec('x', 32)
        >>> 10 >> x
        10 >> x
        >>> (10 >> x).sexpr()
        '(bvashr #x0000000a x)'
        """
        ...

    def __rlshift__(self, other):  # -> BitVecRef:
        """Create the Z3 expression left shift `other << self`.

        Use the function LShR() for the right logical shift

        >>> x = BitVec('x', 32)
        >>> 10 << x
        10 << x
        >>> (10 << x).sexpr()
        '(bvshl #x0000000a x)'
        """
        ...

class BitVecNumRef(BitVecRef):
    """Bit-vector values."""
    def as_long(self):  # -> int:
        """Return a Z3 bit-vector numeral as a Python long (bignum) numeral.

        >>> v = BitVecVal(0xbadc0de, 32)
        >>> v
        195936478
        >>> print("0x%.8x" % v.as_long())
        0x0badc0de
        """
        ...

    def as_signed_long(self):  # -> int:
        """Return a Z3 bit-vector numeral as a Python long (bignum) numeral.
        The most significant bit is assumed to be the sign.

        >>> BitVecVal(4, 3).as_signed_long()
        -4
        >>> BitVecVal(7, 3).as_signed_long()
        -1
        >>> BitVecVal(3, 3).as_signed_long()
        3
        >>> BitVecVal(2**32 - 1, 32).as_signed_long()
        -1
        >>> BitVecVal(2**64 - 1, 64).as_signed_long()
        -1
        """
        ...

    def as_string(self):  # -> Any | Literal['']:
        ...
    def as_binary_string(self):  # -> Any | Literal['']:
        ...

def is_bv(a):  # -> bool:
    """Return `True` if `a` is a Z3 bit-vector expression.

    >>> b = BitVec('b', 32)
    >>> is_bv(b)
    True
    >>> is_bv(b + 10)
    True
    >>> is_bv(Int('x'))
    False
    """
    ...

def is_bv_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 bit-vector numeral value.

    >>> b = BitVec('b', 32)
    >>> is_bv_value(b)
    False
    >>> b = BitVecVal(10, 32)
    >>> b
    10
    >>> is_bv_value(b)
    True
    """
    ...

def BV2Int(a, is_signed=...):  # -> ArithRef:
    """Return the Z3 expression BV2Int(a).

    >>> b = BitVec('b', 3)
    >>> BV2Int(b).sort()
    Int
    >>> x = Int('x')
    >>> x > BV2Int(b)
    x > BV2Int(b)
    >>> x > BV2Int(b, is_signed=False)
    x > BV2Int(b)
    >>> x > BV2Int(b, is_signed=True)
    x > If(b < 0, BV2Int(b) - 8, BV2Int(b))
    >>> solve(x > BV2Int(b), b == 1, x < 3)
    [x = 2, b = 1]
    """
    ...

def Int2BV(a, num_bits):  # -> BitVecRef:
    """Return the z3 expression Int2BV(a, num_bits).
    It is a bit-vector of width num_bits and represents the
    modulo of a by 2^num_bits
    """
    ...

def BitVecSort(sz, ctx=...):  # -> BitVecSortRef:
    """Return a Z3 bit-vector sort of the given size. If `ctx=None`, then the global context is used.

    >>> Byte = BitVecSort(8)
    >>> Word = BitVecSort(16)
    >>> Byte
    BitVec(8)
    >>> x = Const('x', Byte)
    >>> eq(x, BitVec('x', 8))
    True
    """
    ...

def BitVecVal(val, bv, ctx=...):  # -> BitVecNumRef:
    """Return a bit-vector value with the given number of bits. If `ctx=None`, then the global context is used.

    >>> v = BitVecVal(10, 32)
    >>> v
    10
    >>> print("0x%.8x" % v.as_long())
    0x0000000a
    """
    ...

def BitVec(name, bv, ctx=...):  # -> BitVecRef:
    """Return a bit-vector constant named `name`. `bv` may be the number of bits of a bit-vector sort.
    If `ctx=None`, then the global context is used.

    >>> x  = BitVec('x', 16)
    >>> is_bv(x)
    True
    >>> x.size()
    16
    >>> x.sort()
    BitVec(16)
    >>> word = BitVecSort(16)
    >>> x2 = BitVec('x', word)
    >>> eq(x, x2)
    True
    """
    ...

def BitVecs(names, bv, ctx=...):  # -> list[BitVecRef]:
    """Return a tuple of bit-vector constants of size bv.

    >>> x, y, z = BitVecs('x y z', 16)
    >>> x.size()
    16
    >>> x.sort()
    BitVec(16)
    >>> Sum(x, y, z)
    0 + x + y + z
    >>> Product(x, y, z)
    1*x*y*z
    >>> simplify(Product(x, y, z))
    x*y*z
    """
    ...

def Concat(*args):  # -> SeqRef | ReRef | BitVecRef:
    """Create a Z3 bit-vector concatenation expression.

    >>> v = BitVecVal(1, 4)
    >>> Concat(v, v+1, v)
    Concat(Concat(1, 1 + 1), 1)
    >>> simplify(Concat(v, v+1, v))
    289
    >>> print("%.3x" % simplify(Concat(v, v+1, v)).as_long())
    121
    """
    ...

def Extract(high, low, a):  # -> SeqRef | BitVecRef:
    """Create a Z3 bit-vector extraction expression.
    Extract is overloaded to also work on sequence extraction.
    The functions SubString and SubSeq are redirected to Extract.
    For this case, the arguments are reinterpreted as:
        high - is a sequence (string)
        low  - is an offset
        a    - is the length to be extracted

    >>> x = BitVec('x', 8)
    >>> Extract(6, 2, x)
    Extract(6, 2, x)
    >>> Extract(6, 2, x).sort()
    BitVec(5)
    >>> simplify(Extract(StringVal("abcd"),2,1))
    "c"
    """
    ...

def ULE(a, b):  # -> BoolRef:
    """Create the Z3 expression (unsigned) `other <= self`.

    Use the operator <= for signed less than or equal to.

    >>> x, y = BitVecs('x y', 32)
    >>> ULE(x, y)
    ULE(x, y)
    >>> (x <= y).sexpr()
    '(bvsle x y)'
    >>> ULE(x, y).sexpr()
    '(bvule x y)'
    """
    ...

def ULT(a, b):  # -> BoolRef:
    """Create the Z3 expression (unsigned) `other < self`.

    Use the operator < for signed less than.

    >>> x, y = BitVecs('x y', 32)
    >>> ULT(x, y)
    ULT(x, y)
    >>> (x < y).sexpr()
    '(bvslt x y)'
    >>> ULT(x, y).sexpr()
    '(bvult x y)'
    """
    ...

def UGE(a, b):  # -> BoolRef:
    """Create the Z3 expression (unsigned) `other >= self`.

    Use the operator >= for signed greater than or equal to.

    >>> x, y = BitVecs('x y', 32)
    >>> UGE(x, y)
    UGE(x, y)
    >>> (x >= y).sexpr()
    '(bvsge x y)'
    >>> UGE(x, y).sexpr()
    '(bvuge x y)'
    """
    ...

def UGT(a, b):  # -> BoolRef:
    """Create the Z3 expression (unsigned) `other > self`.

    Use the operator > for signed greater than.

    >>> x, y = BitVecs('x y', 32)
    >>> UGT(x, y)
    UGT(x, y)
    >>> (x > y).sexpr()
    '(bvsgt x y)'
    >>> UGT(x, y).sexpr()
    '(bvugt x y)'
    """
    ...

def UDiv(a, b):  # -> BitVecRef:
    """Create the Z3 expression (unsigned) division `self / other`.

    Use the operator / for signed division.

    >>> x = BitVec('x', 32)
    >>> y = BitVec('y', 32)
    >>> UDiv(x, y)
    UDiv(x, y)
    >>> UDiv(x, y).sort()
    BitVec(32)
    >>> (x / y).sexpr()
    '(bvsdiv x y)'
    >>> UDiv(x, y).sexpr()
    '(bvudiv x y)'
    """
    ...

def URem(a, b):  # -> BitVecRef:
    """Create the Z3 expression (unsigned) remainder `self % other`.

    Use the operator % for signed modulus, and SRem() for signed remainder.

    >>> x = BitVec('x', 32)
    >>> y = BitVec('y', 32)
    >>> URem(x, y)
    URem(x, y)
    >>> URem(x, y).sort()
    BitVec(32)
    >>> (x % y).sexpr()
    '(bvsmod x y)'
    >>> URem(x, y).sexpr()
    '(bvurem x y)'
    """
    ...

def SRem(a, b):  # -> BitVecRef:
    """Create the Z3 expression signed remainder.

    Use the operator % for signed modulus, and URem() for unsigned remainder.

    >>> x = BitVec('x', 32)
    >>> y = BitVec('y', 32)
    >>> SRem(x, y)
    SRem(x, y)
    >>> SRem(x, y).sort()
    BitVec(32)
    >>> (x % y).sexpr()
    '(bvsmod x y)'
    >>> SRem(x, y).sexpr()
    '(bvsrem x y)'
    """
    ...

def LShR(a, b):  # -> BitVecRef:
    """Create the Z3 expression logical right shift.

    Use the operator >> for the arithmetical right shift.

    >>> x, y = BitVecs('x y', 32)
    >>> LShR(x, y)
    LShR(x, y)
    >>> (x >> y).sexpr()
    '(bvashr x y)'
    >>> LShR(x, y).sexpr()
    '(bvlshr x y)'
    >>> BitVecVal(4, 3)
    4
    >>> BitVecVal(4, 3).as_signed_long()
    -4
    >>> simplify(BitVecVal(4, 3) >> 1).as_signed_long()
    -2
    >>> simplify(BitVecVal(4, 3) >> 1)
    6
    >>> simplify(LShR(BitVecVal(4, 3), 1))
    2
    >>> simplify(BitVecVal(2, 3) >> 1)
    1
    >>> simplify(LShR(BitVecVal(2, 3), 1))
    1
    """
    ...

def RotateLeft(a, b):  # -> BitVecRef:
    """Return an expression representing `a` rotated to the left `b` times.

    >>> a, b = BitVecs('a b', 16)
    >>> RotateLeft(a, b)
    RotateLeft(a, b)
    >>> simplify(RotateLeft(a, 0))
    a
    >>> simplify(RotateLeft(a, 16))
    a
    """
    ...

def RotateRight(a, b):  # -> BitVecRef:
    """Return an expression representing `a` rotated to the right `b` times.

    >>> a, b = BitVecs('a b', 16)
    >>> RotateRight(a, b)
    RotateRight(a, b)
    >>> simplify(RotateRight(a, 0))
    a
    >>> simplify(RotateRight(a, 16))
    a
    """
    ...

def SignExt(n, a):  # -> BitVecRef:
    """Return a bit-vector expression with `n` extra sign-bits.

    >>> x = BitVec('x', 16)
    >>> n = SignExt(8, x)
    >>> n.size()
    24
    >>> n
    SignExt(8, x)
    >>> n.sort()
    BitVec(24)
    >>> v0 = BitVecVal(2, 2)
    >>> v0
    2
    >>> v0.size()
    2
    >>> v  = simplify(SignExt(6, v0))
    >>> v
    254
    >>> v.size()
    8
    >>> print("%.x" % v.as_long())
    fe
    """
    ...

def ZeroExt(n, a):  # -> BitVecRef:
    """Return a bit-vector expression with `n` extra zero-bits.

    >>> x = BitVec('x', 16)
    >>> n = ZeroExt(8, x)
    >>> n.size()
    24
    >>> n
    ZeroExt(8, x)
    >>> n.sort()
    BitVec(24)
    >>> v0 = BitVecVal(2, 2)
    >>> v0
    2
    >>> v0.size()
    2
    >>> v  = simplify(ZeroExt(6, v0))
    >>> v
    2
    >>> v.size()
    8
    """
    ...

def RepeatBitVec(n, a):  # -> BitVecRef:
    """Return an expression representing `n` copies of `a`.

    >>> x = BitVec('x', 8)
    >>> n = RepeatBitVec(4, x)
    >>> n
    RepeatBitVec(4, x)
    >>> n.size()
    32
    >>> v0 = BitVecVal(10, 4)
    >>> print("%.x" % v0.as_long())
    a
    >>> v = simplify(RepeatBitVec(4, v0))
    >>> v.size()
    16
    >>> print("%.x" % v.as_long())
    aaaa
    """
    ...

def BVRedAnd(a):  # -> BitVecRef:
    """Return the reduction-and expression of `a`."""
    ...

def BVRedOr(a):  # -> BitVecRef:
    """Return the reduction-or expression of `a`."""
    ...

def BVAddNoOverflow(a, b, signed):  # -> BoolRef:
    """A predicate the determines that bit-vector addition does not overflow"""
    ...

def BVAddNoUnderflow(a, b):  # -> BoolRef:
    """A predicate the determines that signed bit-vector addition does not underflow"""
    ...

def BVSubNoOverflow(a, b):  # -> BoolRef:
    """A predicate the determines that bit-vector subtraction does not overflow"""
    ...

def BVSubNoUnderflow(a, b, signed):  # -> BoolRef:
    """A predicate the determines that bit-vector subtraction does not underflow"""
    ...

def BVSDivNoOverflow(a, b):  # -> BoolRef:
    """A predicate the determines that bit-vector signed division does not overflow"""
    ...

def BVSNegNoOverflow(a):  # -> BoolRef:
    """A predicate the determines that bit-vector unary negation does not overflow"""
    ...

def BVMulNoOverflow(a, b, signed):  # -> BoolRef:
    """A predicate the determines that bit-vector multiplication does not overflow"""
    ...

def BVMulNoUnderflow(a, b):  # -> BoolRef:
    """A predicate the determines that bit-vector signed multiplication does not underflow"""
    ...

class ArraySortRef(SortRef):
    """Array sorts."""
    def domain(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the domain of the array sort `self`.

        >>> A = ArraySort(IntSort(), BoolSort())
        >>> A.domain()
        Int
        """
        ...

    def domain_n(
        self, i
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the domain of the array sort `self`."""
        ...

    def range(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the range of the array sort `self`.

        >>> A = ArraySort(IntSort(), BoolSort())
        >>> A.range()
        Bool
        """
        ...

class ArrayRef(ExprRef):
    """Array expressions."""
    def sort(self):  # -> ArraySortRef:
        """Return the array sort of the array expression `self`.

        >>> a = Array('a', IntSort(), BoolSort())
        >>> a.sort()
        Array(Int, Bool)
        """
        ...

    def domain(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Shorthand for `self.sort().domain()`.

        >>> a = Array('a', IntSort(), BoolSort())
        >>> a.domain()
        Int
        """
        ...

    def domain_n(
        self, i
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Shorthand for self.sort().domain_n(i)`."""
        ...

    def range(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Shorthand for `self.sort().range()`.

        >>> a = Array('a', IntSort(), BoolSort())
        >>> a.range()
        Bool
        """
        ...

    def __getitem__(
        self, arg
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return the Z3 expression `self[arg]`.

        >>> a = Array('a', IntSort(), BoolSort())
        >>> i = Int('i')
        >>> a[i]
        a[i]
        >>> a[i].sexpr()
        '(select a i)'
        """
        ...

    def default(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...

def is_array_sort(a):  # -> Any:
    ...
def is_array(a):  # -> bool:
    """Return `True` if `a` is a Z3 array expression.

    >>> a = Array('a', IntSort(), IntSort())
    >>> is_array(a)
    True
    >>> is_array(Store(a, 0, 1))
    True
    >>> is_array(a[0])
    False
    """
    ...

def is_const_array(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 constant array.

    >>> a = K(IntSort(), 10)
    >>> is_const_array(a)
    True
    >>> a = Array('a', IntSort(), IntSort())
    >>> is_const_array(a)
    False
    """
    ...

def is_K(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 constant array.

    >>> a = K(IntSort(), 10)
    >>> is_K(a)
    True
    >>> a = Array('a', IntSort(), IntSort())
    >>> is_K(a)
    False
    """
    ...

def is_map(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 map array expression.

    >>> f = Function('f', IntSort(), IntSort())
    >>> b = Array('b', IntSort(), IntSort())
    >>> a  = Map(f, b)
    >>> a
    Map(f, b)
    >>> is_map(a)
    True
    >>> is_map(b)
    False
    """
    ...

def is_default(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 default array expression.
    >>> d = Default(K(IntSort(), 10))
    >>> is_default(d)
    True
    """
    ...

def get_map_func(a):  # -> FuncDeclRef:
    """Return the function declaration associated with a Z3 map array expression.

    >>> f = Function('f', IntSort(), IntSort())
    >>> b = Array('b', IntSort(), IntSort())
    >>> a  = Map(f, b)
    >>> eq(f, get_map_func(a))
    True
    >>> get_map_func(a)
    f
    >>> get_map_func(a)(0)
    f(0)
    """
    ...

def ArraySort(*sig):  # -> ArraySortRef:
    """Return the Z3 array sort with the given domain and range sorts.

    >>> A = ArraySort(IntSort(), BoolSort())
    >>> A
    Array(Int, Bool)
    >>> A.domain()
    Int
    >>> A.range()
    Bool
    >>> AA = ArraySort(IntSort(), A)
    >>> AA
    Array(Int, Array(Int, Bool))
    """
    ...

def Array(name, *sorts):  # -> ArrayRef:
    """Return an array constant named `name` with the given domain and range sorts.

    >>> a = Array('a', IntSort(), IntSort())
    >>> a.sort()
    Array(Int, Int)
    >>> a[0]
    a[0]
    """
    ...

def Update(
    a, *args
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Return a Z3 store array expression.

    >>> a    = Array('a', IntSort(), IntSort())
    >>> i, v = Ints('i v')
    >>> s    = Update(a, i, v)
    >>> s.sort()
    Array(Int, Int)
    >>> prove(s[i] == v)
    proved
    >>> j    = Int('j')
    >>> prove(Implies(i != j, s[j] == a[j]))
    proved
    """
    ...

def Default(a):
    """Return a default value for array expression.
    >>> b = K(IntSort(), 1)
    >>> prove(Default(b) == 1)
    proved
    """
    ...

def Store(
    a, *args
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Return a Z3 store array expression.

    >>> a    = Array('a', IntSort(), IntSort())
    >>> i, v = Ints('i v')
    >>> s    = Store(a, i, v)
    >>> s.sort()
    Array(Int, Int)
    >>> prove(s[i] == v)
    proved
    >>> j    = Int('j')
    >>> prove(Implies(i != j, s[j] == a[j]))
    proved
    """
    ...

def Select(a, *args):
    """Return a Z3 select array expression.

    >>> a = Array('a', IntSort(), IntSort())
    >>> i = Int('i')
    >>> Select(a, i)
    a[i]
    >>> eq(Select(a, i), a[i])
    True
    """
    ...

def Map(f, *args):  # -> ArrayRef:
    """Return a Z3 map array expression.

    >>> f = Function('f', IntSort(), IntSort(), IntSort())
    >>> a1 = Array('a1', IntSort(), IntSort())
    >>> a2 = Array('a2', IntSort(), IntSort())
    >>> b  = Map(f, a1, a2)
    >>> b
    Map(f, a1, a2)
    >>> prove(b[0] == f(a1[0], a2[0]))
    proved
    """
    ...

def K(dom, v):  # -> ArrayRef:
    """Return a Z3 constant array expression.

    >>> a = K(IntSort(), 10)
    >>> a
    K(Int, 10)
    >>> a.sort()
    Array(Int, Int)
    >>> i = Int('i')
    >>> a[i]
    K(Int, 10)[i]
    >>> simplify(a[i])
    10
    """
    ...

def Ext(
    a, b
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Return extensionality index for one-dimensional arrays.
    >> a, b = Consts('a b', SetSort(IntSort()))
    >> Ext(a, b)
    Ext(a, b)
    """
    ...

def SetHasSize(
    a, k
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def is_select(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 array select application.

    >>> a = Array('a', IntSort(), IntSort())
    >>> is_select(a)
    False
    >>> i = Int('i')
    >>> is_select(a[i])
    True
    """
    ...

def is_store(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 array store application.

    >>> a = Array('a', IntSort(), IntSort())
    >>> is_store(a)
    False
    >>> is_store(Store(a, 0, 1))
    True
    """
    ...

def SetSort(s):  # -> ArraySortRef:
    """Create a set sort over element sort s"""
    ...

def EmptySet(s):  # -> ArrayRef:
    """Create the empty set
    >>> EmptySet(IntSort())
    K(Int, False)
    """
    ...

def FullSet(s):  # -> ArrayRef:
    """Create the full set
    >>> FullSet(IntSort())
    K(Int, True)
    """
    ...

def SetUnion(*args):  # -> ArrayRef:
    """Take the union of sets
    >>> a = Const('a', SetSort(IntSort()))
    >>> b = Const('b', SetSort(IntSort()))
    >>> SetUnion(a, b)
    union(a, b)
    """
    ...

def SetIntersect(*args):  # -> ArrayRef:
    """Take the union of sets
    >>> a = Const('a', SetSort(IntSort()))
    >>> b = Const('b', SetSort(IntSort()))
    >>> SetIntersect(a, b)
    intersection(a, b)
    """
    ...

def SetAdd(s, e):  # -> ArrayRef:
    """Add element e to set s
    >>> a = Const('a', SetSort(IntSort()))
    >>> SetAdd(a, 1)
    Store(a, 1, True)
    """
    ...

def SetDel(s, e):  # -> ArrayRef:
    """Remove element e to set s
    >>> a = Const('a', SetSort(IntSort()))
    >>> SetDel(a, 1)
    Store(a, 1, False)
    """
    ...

def SetComplement(s):  # -> ArrayRef:
    """The complement of set s
    >>> a = Const('a', SetSort(IntSort()))
    >>> SetComplement(a)
    complement(a)
    """
    ...

def SetDifference(a, b):  # -> ArrayRef:
    """The set difference of a and b
    >>> a = Const('a', SetSort(IntSort()))
    >>> b = Const('b', SetSort(IntSort()))
    >>> SetDifference(a, b)
    setminus(a, b)
    """
    ...

def IsMember(e, s):  # -> BoolRef:
    """Check if e is a member of set s
    >>> a = Const('a', SetSort(IntSort()))
    >>> IsMember(1, a)
    a[1]
    """
    ...

def IsSubset(a, b):  # -> BoolRef:
    """Check if a is a subset of b
    >>> a = Const('a', SetSort(IntSort()))
    >>> b = Const('b', SetSort(IntSort()))
    >>> IsSubset(a, b)
    subset(a, b)
    """
    ...

class Datatype:
    """Helper class for declaring Z3 datatypes.

    >>> List = Datatype('List')
    >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
    >>> List.declare('nil')
    >>> List = List.create()
    >>> # List is now a Z3 declaration
    >>> List.nil
    nil
    >>> List.cons(10, List.nil)
    cons(10, nil)
    >>> List.cons(10, List.nil).sort()
    List
    >>> cons = List.cons
    >>> nil  = List.nil
    >>> car  = List.car
    >>> cdr  = List.cdr
    >>> n = cons(1, cons(0, nil))
    >>> n
    cons(1, cons(0, nil))
    >>> simplify(cdr(n))
    cons(0, nil)
    >>> simplify(car(n))
    1
    """
    def __init__(self, name, ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Datatype:
        ...
    def declare_core(self, name, rec_name, *args):  # -> None:
        ...
    def declare(self, name, *args):  # -> None:
        """Declare constructor named `name` with the given accessors `args`.
        Each accessor is a pair `(name, sort)`, where `name` is a string and `sort` a Z3 sort
        or a reference to the datatypes being declared.

        In the following example `List.declare('cons', ('car', IntSort()), ('cdr', List))`
        declares the constructor named `cons` that builds a new List using an integer and a List.
        It also declares the accessors `car` and `cdr`. The accessor `car` extracts the integer
        of a `cons` cell, and `cdr` the list of a `cons` cell. After all constructors were declared,
        we use the method create() to create the actual datatype in Z3.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def create(self):
        """Create a Z3 datatype based on the constructors declared using the method `declare()`.

        The function `CreateDatatypes()` must be used to define mutually recursive datatypes.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        >>> List.nil
        nil
        >>> List.cons(10, List.nil)
        cons(10, nil)
        """
        ...

class ScopedConstructor:
    """Auxiliary object used to create Z3 datatypes."""
    def __init__(self, c, ctx) -> None: ...
    def __del__(self):  # -> None:
        ...

class ScopedConstructorList:
    """Auxiliary object used to create Z3 datatypes."""
    def __init__(self, c, ctx) -> None: ...
    def __del__(self):  # -> None:
        ...

def CreateDatatypes(*ds):  # -> tuple[Any, ...]:
    """Create mutually recursive Z3 datatypes using 1 or more Datatype helper objects.

    In the following example we define a Tree-List using two mutually recursive datatypes.

    >>> TreeList = Datatype('TreeList')
    >>> Tree     = Datatype('Tree')
    >>> # Tree has two constructors: leaf and node
    >>> Tree.declare('leaf', ('val', IntSort()))
    >>> # a node contains a list of trees
    >>> Tree.declare('node', ('children', TreeList))
    >>> TreeList.declare('nil')
    >>> TreeList.declare('cons', ('car', Tree), ('cdr', TreeList))
    >>> Tree, TreeList = CreateDatatypes(Tree, TreeList)
    >>> Tree.val(Tree.leaf(10))
    val(leaf(10))
    >>> simplify(Tree.val(Tree.leaf(10)))
    10
    >>> n1 = Tree.node(TreeList.cons(Tree.leaf(10), TreeList.cons(Tree.leaf(20), TreeList.nil)))
    >>> n1
    node(cons(leaf(10), cons(leaf(20), nil)))
    >>> n2 = Tree.node(TreeList.cons(n1, TreeList.nil))
    >>> simplify(n2 == n1)
    False
    >>> simplify(TreeList.car(Tree.children(n2)) == n1)
    True
    """
    ...

class DatatypeSortRef(SortRef):
    """Datatype sorts."""

    __dict__: dict[str, Any]
    def __call__(self, *args, **kwargs): ...  # -> DatatypeRef:
    def __getattr__(self, name): ...  # -> Any:
    def num_constructors(self):  # -> int:
        """Return the number of constructors in the given Z3 datatype.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        >>> # List is now a Z3 declaration
        >>> List.num_constructors()
        2
        """
        ...

    def constructor(self, idx):  # -> FuncDeclRef:
        """Return a constructor of the datatype `self`.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        >>> # List is now a Z3 declaration
        >>> List.num_constructors()
        2
        >>> List.constructor(0)
        cons
        >>> List.constructor(1)
        nil
        """
        ...

    def __iter__(self):  # -> Iterator[FuncDeclRef]:
        """Iterate over the constructors of the datatype `self`. Only for Enum like datatypes."""

    def recognizer(self, idx):  # -> FuncDeclRef:
        """In Z3, each constructor has an associated recognizer predicate.

        If the constructor is named `name`, then the recognizer `is_name`.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        >>> # List is now a Z3 declaration
        >>> List.num_constructors()
        2
        >>> List.recognizer(0)
        is(cons)
        >>> List.recognizer(1)
        is(nil)
        >>> simplify(List.is_nil(List.cons(10, List.nil)))
        False
        >>> simplify(List.is_cons(List.cons(10, List.nil)))
        True
        >>> l = Const('l', List)
        >>> simplify(List.is_cons(l))
        is(cons, l)
        """
        ...

    def accessor(self, i, j):  # -> FuncDeclRef:
        """In Z3, each constructor has 0 or more accessor.
        The number of accessors is equal to the arity of the constructor.

        >>> List = Datatype('List')
        >>> List.declare('cons', ('car', IntSort()), ('cdr', List))
        >>> List.declare('nil')
        >>> List = List.create()
        >>> List.num_constructors()
        2
        >>> List.constructor(0)
        cons
        >>> num_accs = List.constructor(0).arity()
        >>> num_accs
        2
        >>> List.accessor(0, 0)
        car
        >>> List.accessor(0, 1)
        cdr
        >>> List.constructor(1)
        nil
        >>> num_accs = List.constructor(1).arity()
        >>> num_accs
        0
        """
        ...

class DatatypeRef(ExprRef):
    """Datatype expressions."""
    def __getattr__(self, name: str): ...
    def _replace(self, *kwargs): ...
    def sort(self):  # -> DatatypeSortRef:
        """Return the datatype sort of the datatype expression `self`."""
        ...

def DatatypeSort(name, ctx=...):  # -> DatatypeSortRef:
    """Create a reference to a sort that was declared, or will be declared, as a recursive datatype"""
    ...

def TupleSort(name, sorts, ctx=...):  # -> tuple[Any, Any, list[Any]]:
    """Create a named tuple sort base on a set of underlying sorts
    Example:
        >>> pair, mk_pair, (first, second) = TupleSort("pair", [IntSort(), StringSort()])
    """
    ...

def DisjointSum(name, sorts, ctx=...):  # -> tuple[Any, list[tuple[Any, Any]]]:
    """Create a named tagged union sort base on a set of underlying sorts
    Example:
        >>> sum, ((inject0, extract0), (inject1, extract1)) = DisjointSum("+", [IntSort(), StringSort()])
    """
    ...

def EnumSort(name, values, ctx=...):  # -> tuple[DatatypeSortRef, list[Any]]:
    """Return a new enumeration sort named `name` containing the given values.

    The result is a pair (sort, list of constants).
    Example:
        >>> Color, (red, green, blue) = EnumSort('Color', ['red', 'green', 'blue'])
    """
    ...

class ParamsRef:
    """Set of parameters used to configure Solvers, Tactics and Simplifiers in Z3.

    Consider using the function `args2params` to create instances of this object.
    """
    def __init__(self, ctx=..., params=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> ParamsRef:
        ...
    def __del__(self):  # -> None:
        ...
    def set(self, name, val):  # -> None:
        """Set parameter name with value val."""
        ...

    def __repr__(self):  # -> Any | Literal['']:
        ...
    def validate(self, ds):  # -> None:
        ...

def args2params(arguments, keywords, ctx=...):  # -> ParamsRef:
    """Convert python arguments into a Z3_params object.
    A ':' is added to the keywords, and '_' is replaced with '-'

    >>> args2params(['model', True, 'relevancy', 2], {'elim_and' : True})
    (params model true relevancy 2 elim_and true)
    """
    ...

class ParamDescrsRef:
    """Set of parameter descriptions for Solvers, Tactics and Simplifiers in Z3."""
    def __init__(self, descr, ctx=...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self):  # -> None:
        ...
    def size(self):  # -> int:
        """Return the size of in the parameter description `self`."""
        ...

    def __len__(self):  # -> int:
        """Return the size of in the parameter description `self`."""
        ...

    def get_name(self, i):  # -> Any | Literal['']:
        """Return the i-th parameter name in the parameter description `self`."""
        ...

    def get_kind(self, n):  # -> Any:
        """Return the kind of the parameter named `n`."""
        ...

    def get_documentation(self, n):  # -> Any | Literal['']:
        """Return the documentation string of the parameter named `n`."""
        ...

    def __getitem__(self, arg):  # -> Any | Literal['']:
        ...
    def __repr__(self):  # -> Any | Literal['']:
        ...

class Goal(Z3PPObject):
    """Goal is a collection of constraints we want to find a solution or show to be unsatisfiable (infeasible).

    Goals are processed using Tactics. A Tactic transforms a goal into a set of subgoals.
    A goal has a solution if one of its subgoals has a solution.
    A goal is unsatisfiable if all subgoals are unsatisfiable.
    """
    def __init__(
        self, models=..., unsat_cores=..., proofs=..., ctx=..., goal=...
    ) -> None: ...
    def __del__(self):  # -> None:
        ...
    def depth(self):  # -> int:
        """Return the depth of the goal `self`.
        The depth corresponds to the number of tactics applied to `self`.

        >>> x, y = Ints('x y')
        >>> g = Goal()
        >>> g.add(x == 0, y >= x + 1)
        >>> g.depth()
        0
        >>> r = Then('simplify', 'solve-eqs')(g)
        >>> # r has 1 subgoal
        >>> len(r)
        1
        >>> r[0].depth()
        2
        """
        ...

    def inconsistent(self):  # -> Any:
        """Return `True` if `self` contains the `False` constraints.

        >>> x, y = Ints('x y')
        >>> g = Goal()
        >>> g.inconsistent()
        False
        >>> g.add(x == 0, x == 1)
        >>> g
        [x == 0, x == 1]
        >>> g.inconsistent()
        False
        >>> g2 = Tactic('propagate-values')(g)[0]
        >>> g2.inconsistent()
        True
        """
        ...

    def prec(self):  # -> Any:
        """Return the precision (under-approximation, over-approximation, or precise) of the goal `self`.

        >>> g = Goal()
        >>> g.prec() == Z3_GOAL_PRECISE
        True
        >>> x, y = Ints('x y')
        >>> g.add(x == y + 1)
        >>> g.prec() == Z3_GOAL_PRECISE
        True
        >>> t  = With(Tactic('add-bounds'), add_bound_lower=0, add_bound_upper=10)
        >>> g2 = t(g)[0]
        >>> g2
        [x == y + 1, x <= 10, x >= 0, y <= 10, y >= 0]
        >>> g2.prec() == Z3_GOAL_PRECISE
        False
        >>> g2.prec() == Z3_GOAL_UNDER
        True
        """
        ...

    def precision(self):  # -> Any:
        """Alias for `prec()`.

        >>> g = Goal()
        >>> g.precision() == Z3_GOAL_PRECISE
        True
        """
        ...

    def size(self):  # -> int:
        """Return the number of constraints in the goal `self`.

        >>> g = Goal()
        >>> g.size()
        0
        >>> x, y = Ints('x y')
        >>> g.add(x == 0, y > x)
        >>> g.size()
        2
        """
        ...

    def __len__(self):  # -> int:
        """Return the number of constraints in the goal `self`.

        >>> g = Goal()
        >>> len(g)
        0
        >>> x, y = Ints('x y')
        >>> g.add(x == 0, y > x)
        >>> len(g)
        2
        """
        ...

    def get(
        self, i
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return a constraint in the goal `self`.

        >>> g = Goal()
        >>> x, y = Ints('x y')
        >>> g.add(x == 0, y > x)
        >>> g.get(0)
        x == 0
        >>> g.get(1)
        y > x
        """
        ...

    def __getitem__(
        self, arg
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return a constraint in the goal `self`.

        >>> g = Goal()
        >>> x, y = Ints('x y')
        >>> g.add(x == 0, y > x)
        >>> g[0]
        x == 0
        >>> g[1]
        y > x
        """
        ...

    def assert_exprs(self, *args):  # -> None:
        """Assert constraints into the goal.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.assert_exprs(x > 0, x < 2)
        >>> g
        [x > 0, x < 2]
        """
        ...

    def append(self, *args):  # -> None:
        """Add constraints.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.append(x > 0, x < 2)
        >>> g
        [x > 0, x < 2]
        """
        ...

    def insert(self, *args):  # -> None:
        """Add constraints.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.insert(x > 0, x < 2)
        >>> g
        [x > 0, x < 2]
        """
        ...

    def add(self, *args):  # -> None:
        """Add constraints.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0, x < 2)
        >>> g
        [x > 0, x < 2]
        """
        ...

    def convert_model(self, model):  # -> ModelRef:
        """Retrieve model from a satisfiable goal
        >>> a, b = Ints('a b')
        >>> g = Goal()
        >>> g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a > b)
        >>> t = Then(Tactic('split-clause'), Tactic('solve-eqs'))
        >>> r = t(g)
        >>> r[0]
        [Or(b == 0, b == 1), Not(0 <= b)]
        >>> r[1]
        [Or(b == 0, b == 1), Not(1 <= b)]
        >>> # Remark: the subgoal r[0] is unsatisfiable
        >>> # Creating a solver for solving the second subgoal
        >>> s = Solver()
        >>> s.add(r[1])
        >>> s.check()
        sat
        >>> s.model()
        [b = 0]
        >>> # Model s.model() does not assign a value to `a`
        >>> # It is a model for subgoal `r[1]`, but not for goal `g`
        >>> # The method convert_model creates a model for `g` from a model for `r[1]`.
        >>> r[1].convert_model(s.model())
        [b = 0, a = 1]
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a textual representation of the s-expression representing the goal."""
        ...

    def dimacs(self, include_names=...):  # -> Any | Literal['']:
        """Return a textual representation of the goal in DIMACS format."""
        ...

    def translate(self, target):  # -> Goal:
        """Copy goal `self` to context `target`.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 10)
        >>> g
        [x > 10]
        >>> c2 = Context()
        >>> g2 = g.translate(c2)
        >>> g2
        [x > 10]
        >>> g.ctx == main_ctx()
        True
        >>> g2.ctx == c2
        True
        >>> g2.ctx == main_ctx()
        False
        """
        ...

    def __copy__(self):  # -> Goal:
        ...
    def __deepcopy__(self, memo=...):  # -> Goal:
        ...
    def simplify(self, *arguments, **keywords):  # -> Goal:
        """Return a new simplified goal.

        This method is essentially invoking the simplify tactic.

        >>> g = Goal()
        >>> x = Int('x')
        >>> g.add(x + 1 >= 2)
        >>> g
        [x + 1 >= 2]
        >>> g2 = g.simplify()
        >>> g2
        [x >= 1]
        >>> # g was not modified
        >>> g
        [x + 1 >= 2]
        """
        ...

    def as_expr(
        self,
    ):  # -> BoolRef | PatternRef | QuantifierRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | Probe:
        """Return goal `self` as a single Z3 expression.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.as_expr()
        True
        >>> g.add(x > 1)
        >>> g.as_expr()
        x > 1
        >>> g.add(x < 10)
        >>> g.as_expr()
        And(x > 1, x < 10)
        """
        ...

class AstVector(Z3PPObject):
    """A collection (vector) of ASTs."""
    def __init__(self, v=..., ctx=...) -> None: ...
    def __del__(self):  # -> None:
        ...
    def __len__(self):  # -> int:
        """Return the size of the vector `self`.

        >>> A = AstVector()
        >>> len(A)
        0
        >>> A.push(Int('x'))
        >>> A.push(Int('x'))
        >>> len(A)
        2
        """
        ...

    def __getitem__(
        self, i
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | list[Any] | None:
        """Return the AST at position `i`.

        >>> A = AstVector()
        >>> A.push(Int('x') + 1)
        >>> A.push(Int('y'))
        >>> A[0]
        x + 1
        >>> A[1]
        y
        """
        ...

    def __setitem__(self, i, v):  # -> None:
        """Update AST at position `i`.

        >>> A = AstVector()
        >>> A.push(Int('x') + 1)
        >>> A.push(Int('y'))
        >>> A[0]
        x + 1
        >>> A[0] = Int('x')
        >>> A[0]
        x
        """
        ...

    def push(self, v):  # -> None:
        """Add `v` in the end of the vector.

        >>> A = AstVector()
        >>> len(A)
        0
        >>> A.push(Int('x'))
        >>> len(A)
        1
        """
        ...

    def resize(self, sz):  # -> None:
        """Resize the vector to `sz` elements.

        >>> A = AstVector()
        >>> A.resize(10)
        >>> len(A)
        10
        >>> for i in range(10): A[i] = Int('x')
        >>> A[5]
        x
        """
        ...

    def __contains__(self, item):  # -> bool:
        """Return `True` if the vector contains `item`.

        >>> x = Int('x')
        >>> A = AstVector()
        >>> x in A
        False
        >>> A.push(x)
        >>> x in A
        True
        >>> (x+1) in A
        False
        >>> A.push(x+1)
        >>> (x+1) in A
        True
        >>> A
        [x, x + 1]
        """
        ...

    def translate(self, other_ctx):  # -> AstVector:
        """Copy vector `self` to context `other_ctx`.

        >>> x = Int('x')
        >>> A = AstVector()
        >>> A.push(x)
        >>> c2 = Context()
        >>> B = A.translate(c2)
        >>> B
        [x]
        """
        ...

    def __copy__(self):  # -> AstVector:
        ...
    def __deepcopy__(self, memo=...):  # -> AstVector:
        ...
    def __repr__(self):  # -> str:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a textual representation of the s-expression representing the vector."""
        ...

class AstMap:
    """A mapping from ASTs to ASTs."""
    def __init__(self, m=..., ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> AstMap:
        ...
    def __del__(self):  # -> None:
        ...
    def __len__(self):  # -> int:
        """Return the size of the map.

        >>> M = AstMap()
        >>> len(M)
        0
        >>> x = Int('x')
        >>> M[x] = IntVal(1)
        >>> len(M)
        1
        """
        ...

    def __contains__(self, key):  # -> Any:
        """Return `True` if the map contains key `key`.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x] = x + 1
        >>> x in M
        True
        >>> x+1 in M
        False
        """
        ...

    def __getitem__(
        self, key
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Retrieve the value associated with key `key`.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x] = x + 1
        >>> M[x]
        x + 1
        """
        ...

    def __setitem__(self, k, v):  # -> None:
        """Add/Update key `k` with value `v`.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x] = x + 1
        >>> len(M)
        1
        >>> M[x]
        x + 1
        >>> M[x] = IntVal(1)
        >>> M[x]
        1
        """
        ...

    def __repr__(self):  # -> Any | Literal['']:
        ...
    def erase(self, k):  # -> None:
        """Remove the entry associated with key `k`.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x] = x + 1
        >>> len(M)
        1
        >>> M.erase(x)
        >>> len(M)
        0
        """
        ...

    def reset(self):  # -> None:
        """Remove all entries from the map.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x]   = x + 1
        >>> M[x+x] = IntVal(1)
        >>> len(M)
        2
        >>> M.reset()
        >>> len(M)
        0
        """
        ...

    def keys(self):  # -> AstVector:
        """Return an AstVector containing all keys in the map.

        >>> M = AstMap()
        >>> x = Int('x')
        >>> M[x]   = x + 1
        >>> M[x+x] = IntVal(1)
        >>> M.keys()
        [x, x + x]
        """
        ...

class FuncEntry:
    """Store the value of the interpretation of a function in a particular point."""
    def __init__(self, entry, ctx) -> None: ...
    def __deepcopy__(self, memo=...):  # -> FuncEntry:
        ...
    def __del__(self):  # -> None:
        ...
    def num_args(self):  # -> int:
        """Return the number of arguments in the given entry.

        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> f_i = m[f]
        >>> f_i.num_entries()
        1
        >>> e = f_i.entry(0)
        >>> e.num_args()
        2
        """
        ...

    def arg_value(
        self, idx
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return the value of argument `idx`.

        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> f_i = m[f]
        >>> f_i.num_entries()
        1
        >>> e = f_i.entry(0)
        >>> e
        [1, 2, 20]
        >>> e.num_args()
        2
        >>> e.arg_value(0)
        1
        >>> e.arg_value(1)
        2
        >>> try:
        ...   e.arg_value(2)
        ... except IndexError:
        ...   print("index error")
        index error
        """
        ...

    def value(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return the value of the function at point `self`.

        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> f_i = m[f]
        >>> f_i.num_entries()
        1
        >>> e = f_i.entry(0)
        >>> e
        [1, 2, 20]
        >>> e.num_args()
        2
        >>> e.value()
        20
        """
        ...

    def as_list(
        self,
    ):  # -> list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef]:
        """Return entry `self` as a Python list.
        >>> f = Function('f', IntSort(), IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0, 1) == 10, f(1, 2) == 20, f(1, 0) == 10)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> f_i = m[f]
        >>> f_i.num_entries()
        1
        >>> e = f_i.entry(0)
        >>> e.as_list()
        [1, 2, 20]
        """
        ...

    def __repr__(self):  # -> str:
        ...

class FuncInterp(Z3PPObject):
    """Stores the interpretation of a function in a Z3 model."""
    def __init__(self, f, ctx) -> None: ...
    def __del__(self):  # -> None:
        ...
    def else_value(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | None:
        """
        Return the `else` value for a function interpretation.
        Return None if Z3 did not specify the `else` value for
        this object.

        >>> f = Function('f', IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0) == 1, f(1) == 1, f(2) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[f]
        [2 -> 0, else -> 1]
        >>> m[f].else_value()
        1
        """
        ...

    def num_entries(self):  # -> int:
        """Return the number of entries/points in the function interpretation `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0) == 1, f(1) == 1, f(2) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[f]
        [2 -> 0, else -> 1]
        >>> m[f].num_entries()
        1
        """
        ...

    def arity(self):  # -> int:
        """Return the number of arguments for each entry in the function interpretation `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0) == 1, f(1) == 1, f(2) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[f].arity()
        1
        """
        ...

    def entry(self, idx):  # -> FuncEntry:
        """Return an entry at position `idx < self.num_entries()` in the function interpretation `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0) == 1, f(1) == 1, f(2) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[f]
        [2 -> 0, else -> 1]
        >>> m[f].num_entries()
        1
        >>> m[f].entry(0)
        [2, 0]
        """
        ...

    def translate(self, other_ctx):  # -> ModelRef:
        """Copy model 'self' to context 'other_ctx'."""
        ...

    def __copy__(self):  # -> ModelRef:
        ...
    def __deepcopy__(self, memo=...):  # -> ModelRef:
        ...
    def as_list(
        self,
    ):  # -> list[list[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef]]:
        """Return the function interpretation as a Python list.
        >>> f = Function('f', IntSort(), IntSort())
        >>> s = Solver()
        >>> s.add(f(0) == 1, f(1) == 1, f(2) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[f]
        [2 -> 0, else -> 1]
        >>> m[f].as_list()
        [[2, 0], 1]
        """
        ...

    def __repr__(self):  # -> str:
        ...

class ModelRef(Z3PPObject):
    """Model/Solution of a satisfiability problem (aka system of constraints)."""
    def __init__(self, m, ctx) -> None: ...
    def __del__(self):  # -> None:
        ...
    def __repr__(self):  # -> str:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a textual representation of the s-expression representing the model."""
        ...

    def eval(
        self, t, model_completion=...
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Evaluate the expression `t` in the model `self`.
        If `model_completion` is enabled, then a default interpretation is automatically added
        for symbols that do not have an interpretation in the model `self`.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.eval(x + 1)
        2
        >>> m.eval(x == 1)
        True
        >>> y = Int('y')
        >>> m.eval(y + x)
        1 + y
        >>> m.eval(y)
        y
        >>> m.eval(y, model_completion=True)
        0
        >>> # Now, m contains an interpretation for y
        >>> m.eval(y + x)
        1
        """
        ...

    def evaluate(
        self, t, model_completion=...
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Alias for `eval`.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.evaluate(x + 1)
        2
        >>> m.evaluate(x == 1)
        True
        >>> y = Int('y')
        >>> m.evaluate(y + x)
        1 + y
        >>> m.evaluate(y)
        y
        >>> m.evaluate(y, model_completion=True)
        0
        >>> # Now, m contains an interpretation for y
        >>> m.evaluate(y + x)
        1
        """
        ...

    def __len__(self):  # -> int:
        """Return the number of constant and function declarations in the model `self`.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, f(x) != x)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> len(m)
        2
        """
        ...

    def get_interp(self, decl):
        """Return the interpretation for a given declaration or constant.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2, f(x) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m[x]
        1
        >>> m[f]
        [else -> 0]
        """
        ...

    def num_sorts(self):  # -> int:
        """Return the number of uninterpreted sorts that contain an interpretation in the model `self`.

        >>> A = DeclareSort('A')
        >>> a, b = Consts('a b', A)
        >>> s = Solver()
        >>> s.add(a != b)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.num_sorts()
        1
        """
        ...

    def get_sort(
        self, idx
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        """Return the uninterpreted sort at position `idx` < self.num_sorts().

        >>> A = DeclareSort('A')
        >>> B = DeclareSort('B')
        >>> a1, a2 = Consts('a1 a2', A)
        >>> b1, b2 = Consts('b1 b2', B)
        >>> s = Solver()
        >>> s.add(a1 != a2, b1 != b2)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.num_sorts()
        2
        >>> m.get_sort(0)
        A
        >>> m.get_sort(1)
        B
        """
        ...

    def sorts(
        self,
    ):  # -> list[BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef]:
        """Return all uninterpreted sorts that have an interpretation in the model `self`.

        >>> A = DeclareSort('A')
        >>> B = DeclareSort('B')
        >>> a1, a2 = Consts('a1 a2', A)
        >>> b1, b2 = Consts('b1 b2', B)
        >>> s = Solver()
        >>> s.add(a1 != a2, b1 != b2)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.sorts()
        [A, B]
        """
        ...

    def get_universe(self, s):  # -> AstVector | None:
        """Return the interpretation for the uninterpreted sort `s` in the model `self`.

        >>> A = DeclareSort('A')
        >>> a, b = Consts('a b', A)
        >>> s = Solver()
        >>> s.add(a != b)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.get_universe(A)
        [A!val!1, A!val!0]
        """
        ...

    def __getitem__(self, idx):  # -> FuncDeclRef | AstVector | None:
        """If `idx` is an integer, then the declaration at position `idx` in the model `self` is returned.
        If `idx` is a declaration, then the actual interpretation is returned.

        The elements can be retrieved using position or the actual declaration.

        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2, f(x) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> len(m)
        2
        >>> m[0]
        x
        >>> m[1]
        f
        >>> m[x]
        1
        >>> m[f]
        [else -> 0]
        >>> for d in m: print("%s -> %s" % (d, m[d]))
        x -> 1
        f -> [else -> 0]
        """
        ...

    def decls(self):  # -> list[Any]:
        """Return a list with all symbols that have an interpretation in the model `self`.
        >>> f = Function('f', IntSort(), IntSort())
        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2, f(x) == 0)
        >>> s.check()
        sat
        >>> m = s.model()
        >>> m.decls()
        [x, f]
        """
        ...

    def update_value(self, x, value):  # -> None:
        """Update the interpretation of a constant"""
        ...

    def translate(self, target):  # -> ModelRef:
        """Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`."""
        ...

    def project(
        self, vars, fml
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Perform model-based projection on fml with respect to vars.
        Assume that the model satisfies fml. Then compute a projection fml_p, such
        that vars do not occur free in fml_p, fml_p is true in the model and
        fml_p => exists vars . fml
        """
        ...

    def project_with_witness(
        self, vars, fml
    ):  # -> tuple[PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef, AstMap]:
        """Perform model-based projection, but also include realizer terms for the projected variables"""
        ...

    def __copy__(self):  # -> ModelRef:
        ...
    def __deepcopy__(self, memo=...):  # -> ModelRef:
        ...

def Model(ctx=..., eval=...):  # -> ModelRef:
    ...
def is_as_array(n):  # -> Any | Literal[False]:
    """Return true if n is a Z3 expression of the form (_ as-array f)."""
    ...

def get_as_array_func(n):  # -> FuncDeclRef:
    """Return the function declaration f associated with a Z3 expression of the form (_ as-array f)."""
    ...

class Statistics:
    """Statistics for `Solver.check()`."""
    def __init__(self, stats, ctx) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Statistics:
        ...
    def __del__(self):  # -> None:
        ...
    def __repr__(self):  # -> str | Any:
        ...
    def __len__(self):  # -> int:
        """Return the number of statistical counters.

        >>> x = Int('x')
        >>> s = Then('simplify', 'nlsat').solver()
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        >>> len(st)
        7
        """
        ...

    def __getitem__(self, idx):  # -> tuple[Any | Literal[''], int | Any]:
        """Return the value of statistical counter at position `idx`. The result is a pair (key, value).

        >>> x = Int('x')
        >>> s = Then('simplify', 'nlsat').solver()
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        >>> len(st)
        7
        >>> st[0]
        ('nlsat propagations', 2)
        >>> st[1]
        ('nlsat restarts', 1)
        """
        ...

    def keys(self):  # -> list[Any | str]:
        """Return the list of statistical counters.

        >>> x = Int('x')
        >>> s = Then('simplify', 'nlsat').solver()
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        """
        ...

    def get_key_value(self, key):  # -> int | Any:
        """Return the value of a particular statistical counter.

        >>> x = Int('x')
        >>> s = Then('simplify', 'nlsat').solver()
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        >>> st.get_key_value('nlsat propagations')
        2
        """
        ...

    def __getattr__(self, name):  # -> int | Any:
        """Access the value of statistical using attributes.

        Remark: to access a counter containing blank spaces (e.g., 'nlsat propagations'),
        we should use '_' (e.g., 'nlsat_propagations').

        >>> x = Int('x')
        >>> s = Then('simplify', 'nlsat').solver()
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        >>> st.nlsat_propagations
        2
        >>> st.nlsat_stages
        2
        """
        ...

class CheckSatResult:
    """Represents the result of a satisfiability check: sat, unsat, unknown.

    >>> s = Solver()
    >>> s.check()
    sat
    >>> r = s.check()
    >>> isinstance(r, CheckSatResult)
    True
    """
    def __init__(self, r) -> None: ...
    def __deepcopy__(self, memo=...):  # -> CheckSatResult:
        ...
    def __eq__(self, other) -> bool: ...
    def __ne__(self, other) -> bool: ...
    def __repr__(
        self,
    ):  # -> Literal['<b>sat</b>', '<b>unsat</b>', '<b>unknown</b>', 'sat', 'unsat', 'unknown']:
        ...

sat = ...
unsat = ...
unknown = ...

class Solver(Z3PPObject):
    """
    Solver API provides methods for implementing the main SMT 2.0 commands:
    push, pop, check, get-model, etc.
    """
    def __init__(self, solver=..., ctx=..., logFile=...) -> None: ...
    def __del__(self):  # -> None:
        ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *exc_info):  # -> None:
        ...
    def set(self, *args, **keys):  # -> None:
        """Set a configuration option.
        The method `help()` return a string containing all available options.

        >>> s = Solver()
        >>> # The option MBQI can be set using three different approaches.
        >>> s.set(mbqi=True)
        >>> s.set('MBQI', True)
        >>> s.set(':mbqi', True)
        """
        ...

    def push(self):  # -> None:
        """Create a backtracking point.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0)
        >>> s
        [x > 0]
        >>> s.push()
        >>> s.add(x < 1)
        >>> s
        [x > 0, x < 1]
        >>> s.check()
        unsat
        >>> s.pop()
        >>> s.check()
        sat
        >>> s
        [x > 0]
        """
        ...

    def pop(self, num=...):  # -> None:
        """Backtrack \\c num backtracking points.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0)
        >>> s
        [x > 0]
        >>> s.push()
        >>> s.add(x < 1)
        >>> s
        [x > 0, x < 1]
        >>> s.check()
        unsat
        >>> s.pop()
        >>> s.check()
        sat
        >>> s
        [x > 0]
        """
        ...

    def num_scopes(self):  # -> Any:
        """Return the current number of backtracking points.

        >>> s = Solver()
        >>> s.num_scopes()
        0
        >>> s.push()
        >>> s.num_scopes()
        1
        >>> s.push()
        >>> s.num_scopes()
        2
        >>> s.pop()
        >>> s.num_scopes()
        1
        """
        ...

    def reset(self):  # -> None:
        """Remove all asserted constraints and backtracking points created using `push()`.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0)
        >>> s
        [x > 0]
        >>> s.reset()
        >>> s
        []
        """
        ...

    def assert_exprs(self, *args):  # -> None:
        """Assert constraints into the solver.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.assert_exprs(x > 0, x < 2)
        >>> s
        [x > 0, x < 2]
        """
        ...

    def add(self, *args):  # -> None:
        """Assert constraints into the solver.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0, x < 2)
        >>> s
        [x > 0, x < 2]
        """
        ...

    def __iadd__(self, fml):  # -> Self:
        ...
    def append(self, *args):  # -> None:
        """Assert constraints into the solver.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.append(x > 0, x < 2)
        >>> s
        [x > 0, x < 2]
        """
        ...

    def insert(self, *args):  # -> None:
        """Assert constraints into the solver.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.insert(x > 0, x < 2)
        >>> s
        [x > 0, x < 2]
        """
        ...

    def assert_and_track(self, a, p):  # -> None:
        """Assert constraint `a` and track it in the unsat core using the Boolean constant `p`.

        If `p` is a string, it will be automatically converted into a Boolean constant.

        >>> x = Int('x')
        >>> p3 = Bool('p3')
        >>> s = Solver()
        >>> s.set(unsat_core=True)
        >>> s.assert_and_track(x > 0,  'p1')
        >>> s.assert_and_track(x != 1, 'p2')
        >>> s.assert_and_track(x < 0,  p3)
        >>> print(s.check())
        unsat
        >>> c = s.unsat_core()
        >>> len(c)
        2
        >>> Bool('p1') in c
        True
        >>> Bool('p2') in c
        False
        >>> p3 in c
        True
        """
        ...

    def check(self, *assumptions):  # -> CheckSatResult:
        """Check whether the assertions in the given solver plus the optional assumptions are consistent or not.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.check()
        sat
        >>> s.add(x > 0, x < 2)
        >>> s.check()
        sat
        >>> s.model().eval(x)
        1
        >>> s.add(x < 1)
        >>> s.check()
        unsat
        >>> s.reset()
        >>> s.add(2**x == 4)
        >>> s.check()
        unknown
        """
        ...

    def model(self):  # -> ModelRef:
        """Return a model for the last `check()`.

        This function raises an exception if
        a model is not available (e.g., last `check()` returned unsat).

        >>> s = Solver()
        >>> a = Int('a')
        >>> s.add(a + 2 == 0)
        >>> s.check()
        sat
        >>> s.model()
        [a = -2]
        """
        ...

    def import_model_converter(self, other):  # -> None:
        """Import model converter from other into the current solver"""
        ...

    def interrupt(self):  # -> None:
        """Interrupt the execution of the solver object.
        Remarks: This ensures that the interrupt applies only
        to the given solver object and it applies only if it is running.
        """
        ...

    def unsat_core(self):  # -> AstVector:
        """Return a subset (as an AST vector) of the assumptions provided to the last check().

        These are the assumptions Z3 used in the unsatisfiability proof.
        Assumptions are available in Z3. They are used to extract unsatisfiable cores.
        They may be also used to "retract" assumptions. Note that, assumptions are not really
        "soft constraints", but they can be used to implement them.

        >>> p1, p2, p3 = Bools('p1 p2 p3')
        >>> x, y       = Ints('x y')
        >>> s          = Solver()
        >>> s.add(Implies(p1, x > 0))
        >>> s.add(Implies(p2, y > x))
        >>> s.add(Implies(p2, y < 1))
        >>> s.add(Implies(p3, y > -3))
        >>> s.check(p1, p2, p3)
        unsat
        >>> core = s.unsat_core()
        >>> len(core)
        2
        >>> p1 in core
        True
        >>> p2 in core
        True
        >>> p3 in core
        False
        >>> # "Retracting" p2
        >>> s.check(p1, p3)
        sat
        """
        ...

    def consequences(
        self, assumptions, variables
    ):  # -> tuple[CheckSatResult, list[BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef | FuncDeclRef | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | list[Any] | None]]:
        """Determine fixed values for the variables based on the solver state and assumptions.
        >>> s = Solver()
        >>> a, b, c, d = Bools('a b c d')
        >>> s.add(Implies(a,b), Implies(b, c))
        >>> s.consequences([a],[b,c,d])
        (sat, [Implies(a, b), Implies(a, c)])
        >>> s.consequences([Not(c),d],[a,b,c,d])
        (sat, [Implies(d, d), Implies(Not(c), Not(c)), Implies(Not(c), Not(b)), Implies(Not(c), Not(a))])
        """
        ...

    def from_file(self, filename):  # -> None:
        """Parse assertions from a file"""
        ...

    def from_string(self, s):  # -> None:
        """Parse assertions from a string"""
        ...

    def cube(self, vars=...):  # -> Generator[AstVector, Any, None]:
        """Get set of cubes
        The method takes an optional set of variables that restrict which
        variables may be used as a starting point for cubing.
        If vars is not None, then the first case split is based on a variable in
        this set.
        """
        ...

    def cube_vars(self):  # -> AstVector:
        """Access the set of variables that were touched by the most recently generated cube.
        This set of variables can be used as a starting point for additional cubes.
        The idea is that variables that appear in clauses that are reduced by the most recent
        cube are likely more useful to cube on."""
        ...

    def root(
        self, t
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def next(
        self, t
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def solve_for(
        self, t
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def proof(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Return a proof for the last `check()`. Proof construction must be enabled."""
        ...

    def assertions(self):  # -> AstVector:
        """Return an AST vector containing all added constraints.

        >>> s = Solver()
        >>> s.assertions()
        []
        >>> a = Int('a')
        >>> s.add(a > 0)
        >>> s.add(a < 10)
        >>> s.assertions()
        [a > 0, a < 10]
        """
        ...

    def units(self):  # -> AstVector:
        """Return an AST vector containing all currently inferred units."""
        ...

    def non_units(self):  # -> AstVector:
        """Return an AST vector containing all atomic formulas in solver state that are not units."""
        ...

    def trail_levels(self):  # -> tuple[AstVector, Array[c_uint]]:
        """Return trail and decision levels of the solver state after a check() call."""
        ...

    def set_initial_value(self, var, value):  # -> None:
        """initialize the solver's state by setting the initial value of var to value"""
        ...

    def trail(self):  # -> AstVector:
        """Return trail of the solver state after a check() call."""
        ...

    def statistics(self):  # -> Statistics:
        """Return statistics for the last `check()`.

        >>> s = SimpleSolver()
        >>> x = Int('x')
        >>> s.add(x > 0)
        >>> s.check()
        sat
        >>> st = s.statistics()
        >>> st.get_key_value('final checks')
        1
        >>> len(st) > 0
        True
        >>> st[0] != 0
        True
        """
        ...

    def reason_unknown(self):  # -> Any | Literal['']:
        """Return a string describing why the last `check()` returned `unknown`.

        >>> x = Int('x')
        >>> s = SimpleSolver()
        >>> s.add(2**x == 4)
        >>> s.check()
        unknown
        >>> s.reason_unknown()
        '(incomplete (theory arithmetic))'
        """
        ...

    def help(self):  # -> None:
        """Display a string describing all available options."""
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the parameter description set."""
        ...

    def __repr__(self):  # -> str:
        """Return a formatted string with all added constraints."""
        ...

    def translate(self, target):  # -> Solver:
        """Translate `self` to the context `target`. That is, return a copy of `self` in the context `target`.

        >>> c1 = Context()
        >>> c2 = Context()
        >>> s1 = Solver(ctx=c1)
        >>> s2 = s1.translate(c2)
        """
        ...

    def __copy__(self):  # -> Solver:
        ...
    def __deepcopy__(self, memo=...):  # -> Solver:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a formatted string (in Lisp-like format) with all added constraints.
        We say the string is in s-expression format.

        >>> x = Int('x')
        >>> s = Solver()
        >>> s.add(x > 0)
        >>> s.add(x < 2)
        >>> r = s.sexpr()
        """
        ...

    def dimacs(self, include_names=...):  # -> Any | Literal['']:
        """Return a textual representation of the solver in DIMACS format."""
        ...

    def to_smt2(self):  # -> Any | Literal['']:
        """return SMTLIB2 formatted benchmark for solver's assertions"""
        ...

def SolverFor(logic, ctx=..., logFile=...):  # -> Solver:
    """Create a solver customized for the given logic.

    The parameter `logic` is a string. It should be contains
    the name of a SMT-LIB logic.
    See http://www.smtlib.org/ for the name of all available logics.

    >>> s = SolverFor("QF_LIA")
    >>> x = Int('x')
    >>> s.add(x > 0)
    >>> s.add(x < 2)
    >>> s.check()
    sat
    >>> s.model()
    [x = 1]
    """
    ...

def SimpleSolver(ctx=..., logFile=...):  # -> Solver:
    """Return a simple general purpose solver with limited amount of preprocessing.

    >>> s = SimpleSolver()
    >>> x = Int('x')
    >>> s.add(x > 0)
    >>> s.check()
    sat
    """
    ...

class Fixedpoint(Z3PPObject):
    """Fixedpoint API provides methods for solving with recursive predicates"""
    def __init__(self, fixedpoint=..., ctx=...) -> None: ...
    def __deepcopy__(self, memo=...): ...
    def __del__(self):  # -> None:
        ...
    def set(self, *args, **keys):  # -> None:
        """Set a configuration option. The method `help()` return a string containing all available options."""
        ...

    def help(self):  # -> None:
        """Display a string describing all available options."""
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the parameter description set."""
        ...

    def assert_exprs(self, *args):  # -> None:
        """Assert constraints as background axioms for the fixedpoint solver."""
        ...

    def add(self, *args):  # -> None:
        """Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr."""
        ...

    def __iadd__(self, fml):  # -> Self:
        ...
    def append(self, *args):  # -> None:
        """Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr."""
        ...

    def insert(self, *args):  # -> None:
        """Assert constraints as background axioms for the fixedpoint solver. Alias for assert_expr."""
        ...

    def add_rule(self, head, body=..., name=...):  # -> None:
        """Assert rules defining recursive predicates to the fixedpoint solver.
        >>> a = Bool('a')
        >>> b = Bool('b')
        >>> s = Fixedpoint()
        >>> s.register_relation(a.decl())
        >>> s.register_relation(b.decl())
        >>> s.fact(a)
        >>> s.rule(b, a)
        >>> s.query(b)
        sat
        """
        ...

    def rule(self, head, body=..., name=...):  # -> None:
        """Assert rules defining recursive predicates to the fixedpoint solver. Alias for add_rule."""
        ...

    def fact(self, head, name=...):  # -> None:
        """Assert facts defining recursive predicates to the fixedpoint solver. Alias for add_rule."""
        ...

    def query(self, *query):  # -> CheckSatResult:
        """Query the fixedpoint engine whether formula is derivable.
        You can also pass an tuple or list of recursive predicates.
        """
        ...

    def query_from_lvl(self, lvl, *query):  # -> CheckSatResult:
        """Query the fixedpoint engine whether formula is derivable starting at the given query level."""
        ...

    def update_rule(self, head, body, name):  # -> None:
        """update rule"""
        ...

    def get_answer(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Retrieve answer from last query call."""
        ...

    def get_ground_sat_answer(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Retrieve a ground cex from last query call."""
        ...

    def get_rules_along_trace(self):  # -> AstVector:
        """retrieve rules along the counterexample trace"""
        ...

    def get_rule_names_along_trace(self):  # -> list[LiteralString] | Any:
        """retrieve rule names along the counterexample trace"""
        ...

    def get_num_levels(self, predicate):  # -> Any:
        """Retrieve number of levels used for predicate in PDR engine"""
        ...

    def get_cover_delta(
        self, level, predicate
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        """Retrieve properties known about predicate for the level'th unfolding.
        -1 is treated as the limit (infinity)
        """
        ...

    def add_cover(self, level, predicate, property):  # -> None:
        """Add property to predicate for the level'th unfolding.
        -1 is treated as infinity (infinity)
        """
        ...

    def register_relation(self, *relations):  # -> None:
        """Register relation as recursive"""
        ...

    def set_predicate_representation(self, f, *representations):  # -> None:
        """Control how relation is represented"""
        ...

    def parse_string(self, s):  # -> AstVector:
        """Parse rules and queries from a string"""
        ...

    def parse_file(self, f):  # -> AstVector:
        """Parse rules and queries from a file"""
        ...

    def get_rules(self):  # -> AstVector:
        """retrieve rules that have been added to fixedpoint context"""
        ...

    def get_assertions(self):  # -> AstVector:
        """retrieve assertions that have been added to fixedpoint context"""
        ...

    def __repr__(self):  # -> Any | Literal['']:
        """Return a formatted string with all added rules and constraints."""
        ...

    def sexpr(self):  # -> Any | Literal['']:
        """Return a formatted string (in Lisp-like format) with all added constraints.
        We say the string is in s-expression format.
        """
        ...

    def to_string(self, queries):  # -> Any | Literal['']:
        """Return a formatted string (in Lisp-like format) with all added constraints.
        We say the string is in s-expression format.
        Include also queries.
        """
        ...

    def statistics(self):  # -> Statistics:
        """Return statistics for the last `query()`."""
        ...

    def reason_unknown(self):  # -> Any | Literal['']:
        """Return a string describing why the last `query()` returned `unknown`."""
        ...

    def declare_var(self, *vars):  # -> None:
        """Add variable or several variables.
        The added variable or variables will be bound in the rules
        and queries
        """
        ...

    def abstract(self, fml, is_forall=...):  # -> BoolRef | QuantifierRef:
        ...

class FiniteDomainSortRef(SortRef):
    """Finite domain sort."""
    def size(self):  # -> Any:
        """Return the size of the finite domain sort"""
        ...

def FiniteDomainSort(name, sz, ctx=...):  # -> FiniteDomainSortRef:
    """Create a named finite domain sort of a given size sz"""
    ...

def is_finite_domain_sort(s):  # -> bool:
    """Return True if `s` is a Z3 finite-domain sort.

    >>> is_finite_domain_sort(FiniteDomainSort('S', 100))
    True
    >>> is_finite_domain_sort(IntSort())
    False
    """
    ...

class FiniteDomainRef(ExprRef):
    """Finite-domain expressions."""
    def sort(self):  # -> FiniteDomainSortRef:
        """Return the sort of the finite-domain expression `self`."""
        ...

    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 floating point expression as a Python string."""
        ...

def is_finite_domain(a):  # -> bool:
    """Return `True` if `a` is a Z3 finite-domain expression.

    >>> s = FiniteDomainSort('S', 100)
    >>> b = Const('b', s)
    >>> is_finite_domain(b)
    True
    >>> is_finite_domain(Int('x'))
    False
    """
    ...

class FiniteDomainNumRef(FiniteDomainRef):
    """Integer values."""
    def as_long(self):  # -> int:
        """Return a Z3 finite-domain numeral as a Python long (bignum) numeral.

        >>> s = FiniteDomainSort('S', 100)
        >>> v = FiniteDomainVal(3, s)
        >>> v
        3
        >>> v.as_long() + 1
        4
        """
        ...

    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 finite-domain numeral as a Python string.

        >>> s = FiniteDomainSort('S', 100)
        >>> v = FiniteDomainVal(42, s)
        >>> v.as_string()
        '42'
        """
        ...

def FiniteDomainVal(val, sort, ctx=...):  # -> FiniteDomainNumRef:
    """Return a Z3 finite-domain value. If `ctx=None`, then the global context is used.

    >>> s = FiniteDomainSort('S', 256)
    >>> FiniteDomainVal(255, s)
    255
    >>> FiniteDomainVal('100', s)
    100
    """
    ...

def is_finite_domain_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 finite-domain value.

    >>> s = FiniteDomainSort('S', 100)
    >>> b = Const('b', s)
    >>> is_finite_domain_value(b)
    False
    >>> b = FiniteDomainVal(10, s)
    >>> b
    10
    >>> is_finite_domain_value(b)
    True
    """
    ...

class OptimizeObjective:
    def __init__(self, opt, value, is_max) -> None: ...
    def lower(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def upper(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def lower_values(self):  # -> AstVector:
        ...
    def upper_values(self):  # -> AstVector:
        ...
    def value(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def __str__(self) -> str: ...

_on_models = ...
_on_model_eh = ...

class Optimize(Z3PPObject):
    """Optimize API provides methods for solving using objective functions and weighted soft constraints"""
    def __init__(self, optimize=..., ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Optimize:
        ...
    def __del__(self):  # -> None:
        ...
    def __enter__(self):  # -> Self:
        ...
    def __exit__(self, *exc_info):  # -> None:
        ...
    def set(self, *args, **keys):  # -> None:
        """Set a configuration option.
        The method `help()` return a string containing all available options.
        """
        ...

    def help(self):  # -> None:
        """Display a string describing all available options."""
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the parameter description set."""
        ...

    def assert_exprs(self, *args):  # -> None:
        """Assert constraints as background axioms for the optimize solver."""
        ...

    def add(self, *args):  # -> None:
        """Assert constraints as background axioms for the optimize solver. Alias for assert_expr."""
        ...

    def __iadd__(self, fml):  # -> Self:
        ...
    def assert_and_track(self, a, p):  # -> None:
        """Assert constraint `a` and track it in the unsat core using the Boolean constant `p`.

        If `p` is a string, it will be automatically converted into a Boolean constant.

        >>> x = Int('x')
        >>> p3 = Bool('p3')
        >>> s = Optimize()
        >>> s.assert_and_track(x > 0,  'p1')
        >>> s.assert_and_track(x != 1, 'p2')
        >>> s.assert_and_track(x < 0,  p3)
        >>> print(s.check())
        unsat
        >>> c = s.unsat_core()
        >>> len(c)
        2
        >>> Bool('p1') in c
        True
        >>> Bool('p2') in c
        False
        >>> p3 in c
        True
        """
        ...

    def add_soft(
        self, arg, weight=..., id=...
    ):  # -> list[OptimizeObjective] | OptimizeObjective:
        """Add soft constraint with optional weight and optional identifier.
        If no weight is supplied, then the penalty for violating the soft constraint
        is 1.
        Soft constraints are grouped by identifiers. Soft constraints that are
        added without identifiers are grouped by default.
        """
        ...

    def set_initial_value(self, var, value):  # -> None:
        """initialize the solver's state by setting the initial value of var to value"""
        ...

    def maximize(self, arg):  # -> OptimizeObjective:
        """Add objective function to maximize."""
        ...

    def minimize(self, arg):  # -> OptimizeObjective:
        """Add objective function to minimize."""
        ...

    def push(self):  # -> None:
        """create a backtracking point for added rules, facts and assertions"""
        ...

    def pop(self):  # -> None:
        """restore to previously created backtracking point"""
        ...

    def check(self, *assumptions):  # -> CheckSatResult:
        """Check consistency and produce optimal values."""
        ...

    def reason_unknown(self):  # -> Any | Literal['']:
        """Return a string that describes why the last `check()` returned `unknown`."""
        ...

    def model(self):  # -> ModelRef:
        """Return a model for the last check()."""
        ...

    def unsat_core(self):  # -> AstVector:
        ...
    def lower(
        self, obj
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def upper(
        self, obj
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def lower_values(self, obj):  # -> AstVector:
        ...
    def upper_values(self, obj):  # -> AstVector:
        ...
    def from_file(self, filename):  # -> None:
        """Parse assertions and objectives from a file"""
        ...

    def from_string(self, s):  # -> None:
        """Parse assertions and objectives from a string"""
        ...

    def assertions(self):  # -> AstVector:
        """Return an AST vector containing all added constraints."""
        ...

    def objectives(self):  # -> AstVector:
        """returns set of objective functions"""
        ...

    def __repr__(self):  # -> Any | Literal['']:
        """Return a formatted string with all added rules and constraints."""
        ...

    def sexpr(self):  # -> Any | Literal['']:
        """Return a formatted string (in Lisp-like format) with all added constraints.
        We say the string is in s-expression format.
        """
        ...

    def statistics(self):  # -> Statistics:
        """Return statistics for the last check`."""
        ...

    def set_on_model(self, on_model):  # -> None:
        """Register a callback that is invoked with every incremental improvement to
        objective values. The callback takes a model as argument.
        The life-time of the model is limited to the callback so the
        model has to be (deep) copied if it is to be used after the callback
        """
        ...

class ApplyResult(Z3PPObject):
    """An ApplyResult object contains the subgoals produced by a tactic when applied to a goal.
    It also contains model and proof converters.
    """
    def __init__(self, result, ctx) -> None: ...
    def __deepcopy__(self, memo=...):  # -> ApplyResult:
        ...
    def __del__(self):  # -> None:
        ...
    def __len__(self):  # -> int:
        """Return the number of subgoals in `self`.

        >>> a, b = Ints('a b')
        >>> g = Goal()
        >>> g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a > b)
        >>> t = Tactic('split-clause')
        >>> r = t(g)
        >>> len(r)
        2
        >>> t = Then(Tactic('split-clause'), Tactic('split-clause'))
        >>> len(t(g))
        4
        >>> t = Then(Tactic('split-clause'), Tactic('split-clause'), Tactic('propagate-values'))
        >>> len(t(g))
        1
        """
        ...

    def __getitem__(self, idx):  # -> Goal:
        """Return one of the subgoals stored in ApplyResult object `self`.

        >>> a, b = Ints('a b')
        >>> g = Goal()
        >>> g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a > b)
        >>> t = Tactic('split-clause')
        >>> r = t(g)
        >>> r[0]
        [a == 0, Or(b == 0, b == 1), a > b]
        >>> r[1]
        [a == 1, Or(b == 0, b == 1), a > b]
        """
        ...

    def __repr__(self):  # -> str:
        ...
    def sexpr(self):  # -> Any | Literal['']:
        """Return a textual representation of the s-expression representing the set of subgoals in `self`."""
        ...

    def as_expr(
        self,
    ):  # -> BoolRef | PatternRef | QuantifierRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef | Probe:
        """Return a Z3 expression consisting of all subgoals.

        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 1)
        >>> g.add(Or(x == 2, x == 3))
        >>> r = Tactic('simplify')(g)
        >>> r
        [[Not(x <= 1), Or(x == 2, x == 3)]]
        >>> r.as_expr()
        And(Not(x <= 1), Or(x == 2, x == 3))
        >>> r = Tactic('split-clause')(g)
        >>> r
        [[x > 1, x == 2], [x > 1, x == 3]]
        >>> r.as_expr()
        Or(And(x > 1, x == 2), And(x > 1, x == 3))
        """
        ...

class Simplifier:
    """Simplifiers act as pre-processing utilities for solvers.
    Build a custom simplifier and add it to a solver"""
    def __init__(self, simplifier, ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Simplifier:
        ...
    def __del__(self):  # -> None:
        ...
    def using_params(self, *args, **keys):  # -> Simplifier:
        """Return a simplifier that uses the given configuration options"""
        ...

    def add(self, solver):  # -> Solver:
        """Return a solver that applies the simplification pre-processing specified by the simplifier"""
        ...

    def help(self):  # -> None:
        """Display a string containing a description of the available options for the `self` simplifier."""
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the parameter description set."""
        ...

class Tactic:
    """Tactics transform, solver and/or simplify sets of constraints (Goal).
    A Tactic can be converted into a Solver using the method solver().

    Several combinators are available for creating new tactics using the built-in ones:
    Then(), OrElse(), FailIf(), Repeat(), When(), Cond().
    """
    def __init__(self, tactic, ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Tactic:
        ...
    def __del__(self):  # -> None:
        ...
    def solver(self, logFile=...):  # -> Solver:
        """Create a solver using the tactic `self`.

        The solver supports the methods `push()` and `pop()`, but it
        will always solve each `check()` from scratch.

        >>> t = Then('simplify', 'nlsat')
        >>> s = t.solver()
        >>> x = Real('x')
        >>> s.add(x**2 == 2, x > 0)
        >>> s.check()
        sat
        >>> s.model()
        [x = 1.4142135623?]
        """
        ...

    def apply(self, goal, *arguments, **keywords):  # -> ApplyResult:
        """Apply tactic `self` to the given goal or Z3 Boolean expression using the given options.

        >>> x, y = Ints('x y')
        >>> t = Tactic('solve-eqs')
        >>> t.apply(And(x == 0, y >= x + 1))
        [[y >= 1]]
        """
        ...

    def __call__(self, goal, *arguments, **keywords):  # -> ApplyResult:
        """Apply tactic `self` to the given goal or Z3 Boolean expression using the given options.

        >>> x, y = Ints('x y')
        >>> t = Tactic('solve-eqs')
        >>> t(And(x == 0, y >= x + 1))
        [[y >= 1]]
        """
        ...

    def help(self):  # -> None:
        """Display a string containing a description of the available options for the `self` tactic."""
        ...

    def param_descrs(self):  # -> ParamDescrsRef:
        """Return the parameter description set."""
        ...

def AndThen(*ts, **ks):  # -> Tactic:
    """Return a tactic that applies the tactics in `*ts` in sequence.

    >>> x, y = Ints('x y')
    >>> t = AndThen(Tactic('simplify'), Tactic('solve-eqs'))
    >>> t(And(x == 0, y > x + 1))
    [[Not(y <= 1)]]
    >>> t(And(x == 0, y > x + 1)).as_expr()
    Not(y <= 1)
    """
    ...

def Then(*ts, **ks):  # -> Tactic:
    """Return a tactic that applies the tactics in `*ts` in sequence. Shorthand for AndThen(*ts, **ks).

    >>> x, y = Ints('x y')
    >>> t = Then(Tactic('simplify'), Tactic('solve-eqs'))
    >>> t(And(x == 0, y > x + 1))
    [[Not(y <= 1)]]
    >>> t(And(x == 0, y > x + 1)).as_expr()
    Not(y <= 1)
    """
    ...

def OrElse(*ts, **ks):  # -> Tactic:
    """Return a tactic that applies the tactics in `*ts` until one of them succeeds (it doesn't fail).

    >>> x = Int('x')
    >>> t = OrElse(Tactic('split-clause'), Tactic('skip'))
    >>> # Tactic split-clause fails if there is no clause in the given goal.
    >>> t(x == 0)
    [[x == 0]]
    >>> t(Or(x == 0, x == 1))
    [[x == 0], [x == 1]]
    """
    ...

def ParOr(*ts, **ks):  # -> Tactic:
    """Return a tactic that applies the tactics in `*ts` in parallel until one of them succeeds (it doesn't fail).

    >>> x = Int('x')
    >>> t = ParOr(Tactic('simplify'), Tactic('fail'))
    >>> t(x + 1 == 2)
    [[x == 1]]
    """
    ...

def ParThen(t1, t2, ctx=...):  # -> Tactic:
    """Return a tactic that applies t1 and then t2 to every subgoal produced by t1.
    The subgoals are processed in parallel.

    >>> x, y = Ints('x y')
    >>> t = ParThen(Tactic('split-clause'), Tactic('propagate-values'))
    >>> t(And(Or(x == 1, x == 2), y == x + 1))
    [[x == 1, y == 2], [x == 2, y == 3]]
    """
    ...

def ParAndThen(t1, t2, ctx=...):  # -> Tactic:
    """Alias for ParThen(t1, t2, ctx)."""
    ...

def With(t, *args, **keys):  # -> Tactic:
    """Return a tactic that applies tactic `t` using the given configuration options.

    >>> x, y = Ints('x y')
    >>> t = With(Tactic('simplify'), som=True)
    >>> t((x + 1)*(y + 2) == 0)
    [[2*x + y + x*y == -2]]
    """
    ...

def WithParams(t, p):  # -> Tactic:
    """Return a tactic that applies tactic `t` using the given configuration options.

    >>> x, y = Ints('x y')
    >>> p = ParamsRef()
    >>> p.set("som", True)
    >>> t = WithParams(Tactic('simplify'), p)
    >>> t((x + 1)*(y + 2) == 0)
    [[2*x + y + x*y == -2]]
    """
    ...

def Repeat(t, max=..., ctx=...):  # -> Tactic:
    """Return a tactic that keeps applying `t` until the goal is not modified anymore
    or the maximum number of iterations `max` is reached.

    >>> x, y = Ints('x y')
    >>> c = And(Or(x == 0, x == 1), Or(y == 0, y == 1), x > y)
    >>> t = Repeat(OrElse(Tactic('split-clause'), Tactic('skip')))
    >>> r = t(c)
    >>> for subgoal in r: print(subgoal)
    [x == 0, y == 0, x > y]
    [x == 0, y == 1, x > y]
    [x == 1, y == 0, x > y]
    [x == 1, y == 1, x > y]
    >>> t = Then(t, Tactic('propagate-values'))
    >>> t(c)
    [[x == 1, y == 0]]
    """
    ...

def TryFor(t, ms, ctx=...):  # -> Tactic:
    """Return a tactic that applies `t` to a given goal for `ms` milliseconds.

    If `t` does not terminate in `ms` milliseconds, then it fails.
    """
    ...

def tactics(ctx=...):  # -> list[Any | str]:
    """Return a list of all available tactics in Z3.

    >>> l = tactics()
    >>> l.count('simplify') == 1
    True
    """
    ...

def tactic_description(name, ctx=...):  # -> Any | Literal['']:
    """Return a short description for the tactic named `name`.

    >>> d = tactic_description('simplify')
    """
    ...

def describe_tactics():  # -> None:
    """Display a (tabular) description of all available tactics in Z3."""
    ...

class Probe:
    """Probes are used to inspect a goal (aka problem) and collect information that may be used
    to decide which solver and/or preprocessing step will be used.
    """
    def __init__(self, probe, ctx=...) -> None: ...
    def __deepcopy__(self, memo=...):  # -> Probe:
        ...
    def __del__(self):  # -> None:
        ...
    def __lt__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is less than the value returned by `other`.

        >>> p = Probe('size') < 10
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        1.0
        """
        ...

    def __gt__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is greater than the value returned by `other`.

        >>> p = Probe('size') > 10
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        0.0
        """
        ...

    def __le__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is less than or equal to the value returned by `other`.

        >>> p = Probe('size') <= 2
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        1.0
        """
        ...

    def __ge__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is greater than or equal to the value returned by `other`.

        >>> p = Probe('size') >= 2
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        1.0
        """
        ...

    def __eq__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is equal to the value returned by `other`.

        >>> p = Probe('size') == 2
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        1.0
        """
        ...

    def __ne__(self, other) -> bool:
        """Return a probe that evaluates to "true" when the value returned by `self`
        is not equal to the value returned by `other`.

        >>> p = Probe('size') != 2
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        0.0
        """
        ...

    def __call__(self, goal):  # -> Any:
        """Evaluate the probe `self` in the given goal.

        >>> p = Probe('size')
        >>> x = Int('x')
        >>> g = Goal()
        >>> g.add(x > 0)
        >>> g.add(x < 10)
        >>> p(g)
        2.0
        >>> g.add(x < 20)
        >>> p(g)
        3.0
        >>> p = Probe('num-consts')
        >>> p(g)
        1.0
        >>> p = Probe('is-propositional')
        >>> p(g)
        0.0
        >>> p = Probe('is-qflia')
        >>> p(g)
        1.0
        """
        ...

def is_probe(p):  # -> bool:
    """Return `True` if `p` is a Z3 probe.

    >>> is_probe(Int('x'))
    False
    >>> is_probe(Probe('memory'))
    True
    """
    ...

def probes(ctx=...):  # -> list[Any | str]:
    """Return a list of all available probes in Z3.

    >>> l = probes()
    >>> l.count('memory') == 1
    True
    """
    ...

def probe_description(name, ctx=...):  # -> Any | Literal['']:
    """Return a short description for the probe named `name`.

    >>> d = probe_description('memory')
    """
    ...

def describe_probes():  # -> None:
    """Display a (tabular) description of all available probes in Z3."""
    ...

def FailIf(p, ctx=...):  # -> Tactic:
    """Return a tactic that fails if the probe `p` evaluates to true.
    Otherwise, it returns the input goal unmodified.

    In the following example, the tactic applies 'simplify' if and only if there are
    more than 2 constraints in the goal.

    >>> t = OrElse(FailIf(Probe('size') > 2), Tactic('simplify'))
    >>> x, y = Ints('x y')
    >>> g = Goal()
    >>> g.add(x > 0)
    >>> g.add(y > 0)
    >>> t(g)
    [[x > 0, y > 0]]
    >>> g.add(x == y + 1)
    >>> t(g)
    [[Not(x <= 0), Not(y <= 0), x == 1 + y]]
    """
    ...

def When(p, t, ctx=...):  # -> Tactic:
    """Return a tactic that applies tactic `t` only if probe `p` evaluates to true.
    Otherwise, it returns the input goal unmodified.

    >>> t = When(Probe('size') > 2, Tactic('simplify'))
    >>> x, y = Ints('x y')
    >>> g = Goal()
    >>> g.add(x > 0)
    >>> g.add(y > 0)
    >>> t(g)
    [[x > 0, y > 0]]
    >>> g.add(x == y + 1)
    >>> t(g)
    [[Not(x <= 0), Not(y <= 0), x == 1 + y]]
    """
    ...

def Cond(p, t1, t2, ctx=...):  # -> Tactic:
    """Return a tactic that applies tactic `t1` to a goal if probe `p` evaluates to true, and `t2` otherwise.

    >>> t = Cond(Probe('is-qfnra'), Tactic('qfnra'), Tactic('smt'))
    """
    ...

def simplify(
    a, *arguments, **keywords
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Simplify the expression `a` using the given options.

    This function has many options. Use `help_simplify` to obtain the complete list.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> simplify(x + 1 + y + x + 1)
    2 + 2*x + y
    >>> simplify((x + 1)*(y + 1), som=True)
    1 + x + y + x*y
    >>> simplify(Distinct(x, y, 1), blast_distinct=True)
    And(Not(x == y), Not(x == 1), Not(y == 1))
    >>> simplify(And(x == 0, y == 1), elim_and=True)
    Not(Or(Not(x == 0), Not(y == 1)))
    """
    ...

def help_simplify():  # -> None:
    """Return a string describing all options available for Z3 `simplify` procedure."""
    ...

def simplify_param_descrs():  # -> ParamDescrsRef:
    """Return the set of parameter descriptions for Z3 `simplify` procedure."""
    ...

def substitute(
    t, *m
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Apply substitution m on t, m is a list of pairs of the form (from, to).
    Every occurrence in t of from is replaced with to.

    >>> x = Int('x')
    >>> y = Int('y')
    >>> substitute(x + 1, (x, y + 1))
    y + 1 + 1
    >>> f = Function('f', IntSort(), IntSort())
    >>> substitute(f(x) + f(y), (f(x), IntVal(1)), (f(y), IntVal(1)))
    1 + 1
    """
    ...

def substitute_vars(
    t, *m
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Substitute the free variables in t with the expression in m.

    >>> v0 = Var(0, IntSort())
    >>> v1 = Var(1, IntSort())
    >>> x  = Int('x')
    >>> f  = Function('f', IntSort(), IntSort(), IntSort())
    >>> # replace v0 with x+1 and v1 with x
    >>> substitute_vars(f(v0, v1), x + 1, x)
    f(x + 1, x)
    """
    ...

def substitute_funs(
    t, *m
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Apply substitution m on t, m is a list of pairs of a function and expression (from, to)
    Every occurrence in to of the function from is replaced with the expression to.
    The expression to can have free variables, that refer to the arguments of from.
    For examples, see
    """
    ...

def Sum(*args):  # -> ArithRef | Literal[0]:
    """Create the sum of the Z3 expressions.

    >>> a, b, c = Ints('a b c')
    >>> Sum(a, b, c)
    a + b + c
    >>> Sum([a, b, c])
    a + b + c
    >>> A = IntVector('a', 5)
    >>> Sum(A)
    a__0 + a__1 + a__2 + a__3 + a__4
    """
    ...

def Product(*args):  # -> ArithRef | Literal[1]:
    """Create the product of the Z3 expressions.

    >>> a, b, c = Ints('a b c')
    >>> Product(a, b, c)
    a*b*c
    >>> Product([a, b, c])
    a*b*c
    >>> A = IntVector('a', 5)
    >>> Product(A)
    a__0*a__1*a__2*a__3*a__4
    """
    ...

def Abs(
    arg,
):  # -> Tactic | PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Create the absolute value of an arithmetic expression"""
    ...

def AtMost(*args):  # -> BoolRef:
    """Create an at-most Pseudo-Boolean k constraint.

    >>> a, b, c = Bools('a b c')
    >>> f = AtMost(a, b, c, 2)
    """
    ...

def AtLeast(*args):  # -> BoolRef:
    """Create an at-least Pseudo-Boolean k constraint.

    >>> a, b, c = Bools('a b c')
    >>> f = AtLeast(a, b, c, 2)
    """
    ...

def PbLe(args, k):  # -> BoolRef:
    """Create a Pseudo-Boolean inequality k constraint.

    >>> a, b, c = Bools('a b c')
    >>> f = PbLe(((a,1),(b,3),(c,2)), 3)
    """
    ...

def PbGe(args, k):  # -> BoolRef:
    """Create a Pseudo-Boolean inequality k constraint.

    >>> a, b, c = Bools('a b c')
    >>> f = PbGe(((a,1),(b,3),(c,2)), 3)
    """
    ...

def PbEq(args, k, ctx=...):  # -> BoolRef:
    """Create a Pseudo-Boolean equality k constraint.

    >>> a, b, c = Bools('a b c')
    >>> f = PbEq(((a,1),(b,3),(c,2)), 3)
    """
    ...

def solve(*args, **keywords):  # -> None:
    """Solve the constraints `*args`.

    This is a simple function for creating demonstrations. It creates a solver,
    configure it using the options in `keywords`, adds the constraints
    in `args`, and invokes check.

    >>> a = Int('a')
    >>> solve(a > 0, a < 2)
    [a = 1]
    """
    ...

def solve_using(s, *args, **keywords):  # -> None:
    """Solve the constraints `*args` using solver `s`.

    This is a simple function for creating demonstrations. It is similar to `solve`,
    but it uses the given solver `s`.
    It configures solver `s` using the options in `keywords`, adds the constraints
    in `args`, and invokes check.
    """
    ...

def prove(claim, show=..., **keywords):  # -> None:
    """Try to prove the given claim.

    This is a simple function for creating demonstrations.  It tries to prove
    `claim` by showing the negation is unsatisfiable.

    >>> p, q = Bools('p q')
    >>> prove(Not(And(p, q)) == Or(Not(p), Not(q)))
    proved
    """
    ...

class ParserContext:
    def __init__(self, ctx=...) -> None: ...
    def __del__(self):  # -> None:
        ...
    def add_sort(self, sort):  # -> None:
        ...
    def add_decl(self, decl):  # -> None:
        ...
    def from_string(self, s):  # -> AstVector:
        ...

def parse_smt2_string(s, sorts=..., decls=..., ctx=...):  # -> AstVector:
    """Parse a string in SMT 2.0 format using the given sorts and decls.

    The arguments sorts and decls are Python dictionaries used to initialize
    the symbol table used for the SMT 2.0 parser.

    >>> parse_smt2_string('(declare-const x Int) (assert (> x 0)) (assert (< x 10))')
    [x > 0, x < 10]
    >>> x, y = Ints('x y')
    >>> f = Function('f', IntSort(), IntSort())
    >>> parse_smt2_string('(assert (> (+ foo (g bar)) 0))', decls={ 'foo' : x, 'bar' : y, 'g' : f})
    [x + f(y) > 0]
    >>> parse_smt2_string('(declare-const a U) (assert (> a 0))', sorts={ 'U' : IntSort() })
    [a > 0]
    """
    ...

def parse_smt2_file(f, sorts=..., decls=..., ctx=...):  # -> AstVector:
    """Parse a file in SMT 2.0 format using the given sorts and decls.

    This function is similar to parse_smt2_string().
    """
    ...

_dflt_rounding_mode = ...
_dflt_fpsort_ebits = ...
_dflt_fpsort_sbits = ...

def get_default_rounding_mode(ctx=...):  # -> FPRMRef | None:
    """Retrieves the global default rounding mode."""
    ...

_ROUNDING_MODES = ...

def set_default_rounding_mode(rm, ctx=...):  # -> None:
    ...
def get_default_fp_sort(ctx=...):  # -> FPSortRef:
    ...
def set_default_fp_sort(ebits, sbits, ctx=...):  # -> None:
    ...

class FPSortRef(SortRef):
    """Floating-point sort."""
    def ebits(self):  # -> int:
        """Retrieves the number of bits reserved for the exponent in the FloatingPoint sort `self`.
        >>> b = FPSort(8, 24)
        >>> b.ebits()
        8
        """
        ...

    def sbits(self):  # -> int:
        """Retrieves the number of bits reserved for the significand in the FloatingPoint sort `self`.
        >>> b = FPSort(8, 24)
        >>> b.sbits()
        24
        """
        ...

    def cast(self, val):  # -> FPNumRef:
        """Try to cast `val` as a floating-point expression.
        >>> b = FPSort(8, 24)
        >>> b.cast(1.0)
        1
        >>> b.cast(1.0).sexpr()
        '(fp #b0 #x7f #b00000000000000000000000)'
        """
        ...

def Float16(ctx=...):  # -> FPSortRef:
    """Floating-point 16-bit (half) sort."""
    ...

def FloatHalf(ctx=...):  # -> FPSortRef:
    """Floating-point 16-bit (half) sort."""
    ...

def Float32(ctx=...):  # -> FPSortRef:
    """Floating-point 32-bit (single) sort."""
    ...

def FloatSingle(ctx=...):  # -> FPSortRef:
    """Floating-point 32-bit (single) sort."""
    ...

def Float64(ctx=...):  # -> FPSortRef:
    """Floating-point 64-bit (double) sort."""
    ...

def FloatDouble(ctx=...):  # -> FPSortRef:
    """Floating-point 64-bit (double) sort."""
    ...

def Float128(ctx=...):  # -> FPSortRef:
    """Floating-point 128-bit (quadruple) sort."""
    ...

def FloatQuadruple(ctx=...):  # -> FPSortRef:
    """Floating-point 128-bit (quadruple) sort."""
    ...

class FPRMSortRef(SortRef):
    """ "Floating-point rounding mode sort."""

    ...

def is_fp_sort(s):  # -> bool:
    """Return True if `s` is a Z3 floating-point sort.

    >>> is_fp_sort(FPSort(8, 24))
    True
    >>> is_fp_sort(IntSort())
    False
    """
    ...

def is_fprm_sort(s):  # -> bool:
    """Return True if `s` is a Z3 floating-point rounding mode sort.

    >>> is_fprm_sort(FPSort(8, 24))
    False
    >>> is_fprm_sort(RNE().sort())
    True
    """
    ...

class FPRef(ExprRef):
    """Floating-point expressions."""
    def sort(self):  # -> FPSortRef:
        """Return the sort of the floating-point expression `self`.

        >>> x = FP('1.0', FPSort(8, 24))
        >>> x.sort()
        FPSort(8, 24)
        >>> x.sort() == FPSort(8, 24)
        True
        """
        ...

    def ebits(self):  # -> int:
        """Retrieves the number of bits reserved for the exponent in the FloatingPoint expression `self`.
        >>> b = FPSort(8, 24)
        >>> b.ebits()
        8
        """
        ...

    def sbits(self):  # -> int:
        """Retrieves the number of bits reserved for the exponent in the FloatingPoint expression `self`.
        >>> b = FPSort(8, 24)
        >>> b.sbits()
        24
        """
        ...

    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 floating point expression as a Python string."""
        ...

    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...
    def __add__(self, other):  # -> FPRef:
        """Create the Z3 expression `self + other`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x + y
        x + y
        >>> (x + y).sort()
        FPSort(8, 24)
        """
        ...

    def __radd__(self, other):  # -> FPRef:
        """Create the Z3 expression `other + self`.

        >>> x = FP('x', FPSort(8, 24))
        >>> 10 + x
        1.25*(2**3) + x
        """
        ...

    def __sub__(self, other):  # -> FPRef:
        """Create the Z3 expression `self - other`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x - y
        x - y
        >>> (x - y).sort()
        FPSort(8, 24)
        """
        ...

    def __rsub__(self, other):  # -> FPRef:
        """Create the Z3 expression `other - self`.

        >>> x = FP('x', FPSort(8, 24))
        >>> 10 - x
        1.25*(2**3) - x
        """
        ...

    def __mul__(self, other):  # -> FPRef:
        """Create the Z3 expression `self * other`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x * y
        x * y
        >>> (x * y).sort()
        FPSort(8, 24)
        >>> 10 * y
        1.25*(2**3) * y
        """
        ...

    def __rmul__(self, other):  # -> FPRef:
        """Create the Z3 expression `other * self`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x * y
        x * y
        >>> x * 10
        x * 1.25*(2**3)
        """
        ...

    def __pos__(self):  # -> Self:
        """Create the Z3 expression `+self`."""
        ...

    def __neg__(self):  # -> FPRef:
        """Create the Z3 expression `-self`.

        >>> x = FP('x', Float32())
        >>> -x
        -x
        """
        ...

    def __div__(self, other):  # -> FPRef:
        """Create the Z3 expression `self / other`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x / y
        x / y
        >>> (x / y).sort()
        FPSort(8, 24)
        >>> 10 / y
        1.25*(2**3) / y
        """
        ...

    def __rdiv__(self, other):  # -> FPRef:
        """Create the Z3 expression `other / self`.

        >>> x = FP('x', FPSort(8, 24))
        >>> y = FP('y', FPSort(8, 24))
        >>> x / y
        x / y
        >>> x / 10
        x / 1.25*(2**3)
        """
        ...

    def __truediv__(self, other):  # -> FPRef:
        """Create the Z3 expression division `self / other`."""
        ...

    def __rtruediv__(self, other):  # -> FPRef:
        """Create the Z3 expression division `other / self`."""
        ...

    def __mod__(self, other):  # -> FPRef:
        """Create the Z3 expression mod `self % other`."""
        ...

    def __rmod__(self, other):  # -> FPRef:
        """Create the Z3 expression mod `other % self`."""
        ...

class FPRMRef(ExprRef):
    """Floating-point rounding mode expressions"""
    def as_string(self):  # -> Any | Literal['']:
        """Return a Z3 floating point expression as a Python string."""
        ...

def RoundNearestTiesToEven(ctx=...):  # -> FPRMRef:
    ...
def RNE(ctx=...):  # -> FPRMRef:
    ...
def RoundNearestTiesToAway(ctx=...):  # -> FPRMRef:
    ...
def RNA(ctx=...):  # -> FPRMRef:
    ...
def RoundTowardPositive(ctx=...):  # -> FPRMRef:
    ...
def RTP(ctx=...):  # -> FPRMRef:
    ...
def RoundTowardNegative(ctx=...):  # -> FPRMRef:
    ...
def RTN(ctx=...):  # -> FPRMRef:
    ...
def RoundTowardZero(ctx=...):  # -> FPRMRef:
    ...
def RTZ(ctx=...):  # -> FPRMRef:
    ...
def is_fprm(a):  # -> bool:
    """Return `True` if `a` is a Z3 floating-point rounding mode expression.

    >>> rm = RNE()
    >>> is_fprm(rm)
    True
    >>> rm = 1.0
    >>> is_fprm(rm)
    False
    """
    ...

def is_fprm_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 floating-point rounding mode numeral value."""
    ...

class FPNumRef(FPRef):
    """The sign of the numeral.

    >>> x = FPVal(+1.0, FPSort(8, 24))
    >>> x.sign()
    False
    >>> x = FPVal(-1.0, FPSort(8, 24))
    >>> x.sign()
    True
    """
    def sign(self):  # -> bool:
        ...
    def sign_as_bv(self):  # -> BitVecNumRef:
        ...
    def significand(self):  # -> Any | Literal['']:
        ...
    def significand_as_long(self):  # -> Any:
        ...
    def significand_as_bv(self):  # -> BitVecNumRef:
        ...
    def exponent(self, biased=...):  # -> Any | Literal['']:
        ...
    def exponent_as_long(self, biased=...):  # -> Any:
        ...
    def exponent_as_bv(self, biased=...):  # -> BitVecNumRef:
        ...
    def isNaN(self):  # -> Any:
        ...
    def isInf(self):  # -> Any:
        ...
    def isZero(self):  # -> Any:
        ...
    def isNormal(self):  # -> Any:
        ...
    def isSubnormal(self):  # -> Any:
        ...
    def isPositive(self):  # -> Any:
        ...
    def isNegative(self):  # -> Any:
        ...
    def as_string(self):  # -> str:
        ...

def is_fp(a):  # -> bool:
    """Return `True` if `a` is a Z3 floating-point expression.

    >>> b = FP('b', FPSort(8, 24))
    >>> is_fp(b)
    True
    >>> is_fp(b + 1.0)
    True
    >>> is_fp(Int('x'))
    False
    """
    ...

def is_fp_value(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 floating-point numeral value.

    >>> b = FP('b', FPSort(8, 24))
    >>> is_fp_value(b)
    False
    >>> b = FPVal(1.0, FPSort(8, 24))
    >>> b
    1
    >>> is_fp_value(b)
    True
    """
    ...

def FPSort(ebits, sbits, ctx=...):  # -> FPSortRef:
    """Return a Z3 floating-point sort of the given sizes. If `ctx=None`, then the global context is used.

    >>> Single = FPSort(8, 24)
    >>> Double = FPSort(11, 53)
    >>> Single
    FPSort(8, 24)
    >>> x = Const('x', Single)
    >>> eq(x, FP('x', FPSort(8, 24)))
    True
    """
    ...

def fpNaN(s):  # -> FPNumRef:
    """Create a Z3 floating-point NaN term.

    >>> s = FPSort(8, 24)
    >>> set_fpa_pretty(True)
    >>> fpNaN(s)
    NaN
    >>> pb = get_fpa_pretty()
    >>> set_fpa_pretty(False)
    >>> fpNaN(s)
    fpNaN(FPSort(8, 24))
    >>> set_fpa_pretty(pb)
    """
    ...

def fpPlusInfinity(s):  # -> FPNumRef:
    """Create a Z3 floating-point +oo term.

    >>> s = FPSort(8, 24)
    >>> pb = get_fpa_pretty()
    >>> set_fpa_pretty(True)
    >>> fpPlusInfinity(s)
    +oo
    >>> set_fpa_pretty(False)
    >>> fpPlusInfinity(s)
    fpPlusInfinity(FPSort(8, 24))
    >>> set_fpa_pretty(pb)
    """
    ...

def fpMinusInfinity(s):  # -> FPNumRef:
    """Create a Z3 floating-point -oo term."""
    ...

def fpInfinity(s, negative):  # -> FPNumRef:
    """Create a Z3 floating-point +oo or -oo term."""
    ...

def fpPlusZero(s):  # -> FPNumRef:
    """Create a Z3 floating-point +0.0 term."""
    ...

def fpMinusZero(s):  # -> FPNumRef:
    """Create a Z3 floating-point -0.0 term."""
    ...

def fpZero(s, negative):  # -> FPNumRef:
    """Create a Z3 floating-point +0.0 or -0.0 term."""
    ...

def FPVal(sig, exp=..., fps=..., ctx=...):  # -> FPNumRef:
    """Return a floating-point value of value `val` and sort `fps`.
    If `ctx=None`, then the global context is used.

    >>> v = FPVal(20.0, FPSort(8, 24))
    >>> v
    1.25*(2**4)
    >>> print("0x%.8x" % v.exponent_as_long(False))
    0x00000004
    >>> v = FPVal(2.25, FPSort(8, 24))
    >>> v
    1.125*(2**1)
    >>> v = FPVal(-2.25, FPSort(8, 24))
    >>> v
    -1.125*(2**1)
    >>> FPVal(-0.0, FPSort(8, 24))
    -0.0
    >>> FPVal(0.0, FPSort(8, 24))
    +0.0
    >>> FPVal(+0.0, FPSort(8, 24))
    +0.0
    """
    ...

def FP(name, fpsort, ctx=...):  # -> FPRef:
    """Return a floating-point constant named `name`.
    `fpsort` is the floating-point sort.
    If `ctx=None`, then the global context is used.

    >>> x  = FP('x', FPSort(8, 24))
    >>> is_fp(x)
    True
    >>> x.ebits()
    8
    >>> x.sort()
    FPSort(8, 24)
    >>> word = FPSort(8, 24)
    >>> x2 = FP('x', word)
    >>> eq(x, x2)
    True
    """
    ...

def FPs(names, fpsort, ctx=...):  # -> list[FPRef]:
    """Return an array of floating-point constants.

    >>> x, y, z = FPs('x y z', FPSort(8, 24))
    >>> x.sort()
    FPSort(8, 24)
    >>> x.sbits()
    24
    >>> x.ebits()
    8
    >>> fpMul(RNE(), fpAdd(RNE(), x, y), z)
    (x + y) * z
    """
    ...

def fpAbs(a, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point absolute value expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FPVal(1.0, s)
    >>> fpAbs(x)
    fpAbs(1)
    >>> y = FPVal(-20.0, s)
    >>> y
    -1.25*(2**4)
    >>> fpAbs(y)
    fpAbs(-1.25*(2**4))
    >>> fpAbs(-1.25*(2**4))
    fpAbs(-1.25*(2**4))
    >>> fpAbs(x).sort()
    FPSort(8, 24)
    """
    ...

def fpNeg(a, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point addition expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> fpNeg(x)
    -x
    >>> fpNeg(x).sort()
    FPSort(8, 24)
    """
    ...

def fpAdd(rm, a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point addition expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpAdd(rm, x, y)
    x + y
    >>> fpAdd(RTZ(), x, y) # default rounding mode is RTZ
    fpAdd(RTZ(), x, y)
    >>> fpAdd(rm, x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpSub(rm, a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point subtraction expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpSub(rm, x, y)
    x - y
    >>> fpSub(rm, x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpMul(rm, a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point multiplication expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpMul(rm, x, y)
    x * y
    >>> fpMul(rm, x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpDiv(rm, a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point division expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpDiv(rm, x, y)
    x / y
    >>> fpDiv(rm, x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpRem(a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point remainder expression.

    >>> s = FPSort(8, 24)
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpRem(x, y)
    fpRem(x, y)
    >>> fpRem(x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpMin(a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point minimum expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpMin(x, y)
    fpMin(x, y)
    >>> fpMin(x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpMax(a, b, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point maximum expression.

    >>> s = FPSort(8, 24)
    >>> rm = RNE()
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpMax(x, y)
    fpMax(x, y)
    >>> fpMax(x, y).sort()
    FPSort(8, 24)
    """
    ...

def fpFMA(rm, a, b, c, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point fused multiply-add expression."""
    ...

def fpSqrt(rm, a, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point square root expression."""
    ...

def fpRoundToIntegral(rm, a, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point roundToIntegral expression."""
    ...

def fpIsNaN(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isNaN expression.

    >>> s = FPSort(8, 24)
    >>> x = FP('x', s)
    >>> y = FP('y', s)
    >>> fpIsNaN(x)
    fpIsNaN(x)
    """
    ...

def fpIsInf(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isInfinite expression.

    >>> s = FPSort(8, 24)
    >>> x = FP('x', s)
    >>> fpIsInf(x)
    fpIsInf(x)
    """
    ...

def fpIsZero(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isZero expression."""
    ...

def fpIsNormal(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isNormal expression."""
    ...

def fpIsSubnormal(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isSubnormal expression."""
    ...

def fpIsNegative(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isNegative expression."""
    ...

def fpIsPositive(a, ctx=...):  # -> BoolRef:
    """Create a Z3 floating-point isPositive expression."""
    ...

def fpLT(a, b, ctx=...):  # -> BoolRef:
    """Create the Z3 floating-point expression `other < self`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpLT(x, y)
    x < y
    >>> (x < y).sexpr()
    '(fp.lt x y)'
    """
    ...

def fpLEQ(a, b, ctx=...):  # -> BoolRef:
    """Create the Z3 floating-point expression `other <= self`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpLEQ(x, y)
    x <= y
    >>> (x <= y).sexpr()
    '(fp.leq x y)'
    """
    ...

def fpGT(a, b, ctx=...):  # -> BoolRef:
    """Create the Z3 floating-point expression `other > self`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpGT(x, y)
    x > y
    >>> (x > y).sexpr()
    '(fp.gt x y)'
    """
    ...

def fpGEQ(a, b, ctx=...):  # -> BoolRef:
    """Create the Z3 floating-point expression `other >= self`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpGEQ(x, y)
    x >= y
    >>> (x >= y).sexpr()
    '(fp.geq x y)'
    """
    ...

def fpEQ(a, b, ctx=...):  # -> BoolRef:
    """Create the Z3 floating-point expression `fpEQ(other, self)`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpEQ(x, y)
    fpEQ(x, y)
    >>> fpEQ(x, y).sexpr()
    '(fp.eq x y)'
    """
    ...

def fpNEQ(a, b, ctx=...):  # -> Probe | BoolRef:
    """Create the Z3 floating-point expression `Not(fpEQ(other, self))`.

    >>> x, y = FPs('x y', FPSort(8, 24))
    >>> fpNEQ(x, y)
    Not(fpEQ(x, y))
    >>> (x != y).sexpr()
    '(distinct x y)'
    """
    ...

def fpFP(sgn, exp, sig, ctx=...):  # -> FPRef:
    """Create the Z3 floating-point value `fpFP(sgn, sig, exp)` from the three bit-vectors sgn, sig, and exp.

    >>> s = FPSort(8, 24)
    >>> x = fpFP(BitVecVal(1, 1), BitVecVal(2**7-1, 8), BitVecVal(2**22, 23))
    >>> print(x)
    fpFP(1, 127, 4194304)
    >>> xv = FPVal(-1.5, s)
    >>> print(xv)
    -1.5
    >>> slvr = Solver()
    >>> slvr.add(fpEQ(x, xv))
    >>> slvr.check()
    sat
    >>> xv = FPVal(+1.5, s)
    >>> print(xv)
    1.5
    >>> slvr = Solver()
    >>> slvr.add(fpEQ(x, xv))
    >>> slvr.check()
    unsat
    """
    ...

def fpToFP(a1, a2=..., a3=..., ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression from other term sorts
    to floating-point.

    From a bit-vector term in IEEE 754-2008 format:
    >>> x = FPVal(1.0, Float32())
    >>> x_bv = fpToIEEEBV(x)
    >>> simplify(fpToFP(x_bv, Float32()))
    1

    From a floating-point term with different precision:
    >>> x = FPVal(1.0, Float32())
    >>> x_db = fpToFP(RNE(), x, Float64())
    >>> x_db.sort()
    FPSort(11, 53)

    From a real term:
    >>> x_r = RealVal(1.5)
    >>> simplify(fpToFP(RNE(), x_r, Float32()))
    1.5

    From a signed bit-vector term:
    >>> x_signed = BitVecVal(-5, BitVecSort(32))
    >>> simplify(fpToFP(RNE(), x_signed, Float32()))
    -1.25*(2**2)
    """
    ...

def fpBVToFP(v, sort, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression that represents the
    conversion from a bit-vector term to a floating-point term.

    >>> x_bv = BitVecVal(0x3F800000, 32)
    >>> x_fp = fpBVToFP(x_bv, Float32())
    >>> x_fp
    fpToFP(1065353216)
    >>> simplify(x_fp)
    1
    """
    ...

def fpFPToFP(rm, v, sort, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression that represents the
    conversion from a floating-point term to a floating-point term of different precision.

    >>> x_sgl = FPVal(1.0, Float32())
    >>> x_dbl = fpFPToFP(RNE(), x_sgl, Float64())
    >>> x_dbl
    fpToFP(RNE(), 1)
    >>> simplify(x_dbl)
    1
    >>> x_dbl.sort()
    FPSort(11, 53)
    """
    ...

def fpRealToFP(rm, v, sort, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression that represents the
    conversion from a real term to a floating-point term.

    >>> x_r = RealVal(1.5)
    >>> x_fp = fpRealToFP(RNE(), x_r, Float32())
    >>> x_fp
    fpToFP(RNE(), 3/2)
    >>> simplify(x_fp)
    1.5
    """
    ...

def fpSignedToFP(rm, v, sort, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression that represents the
    conversion from a signed bit-vector term (encoding an integer) to a floating-point term.

    >>> x_signed = BitVecVal(-5, BitVecSort(32))
    >>> x_fp = fpSignedToFP(RNE(), x_signed, Float32())
    >>> x_fp
    fpToFP(RNE(), 4294967291)
    >>> simplify(x_fp)
    -1.25*(2**2)
    """
    ...

def fpUnsignedToFP(rm, v, sort, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression that represents the
    conversion from an unsigned bit-vector term (encoding an integer) to a floating-point term.

    >>> x_signed = BitVecVal(-5, BitVecSort(32))
    >>> x_fp = fpUnsignedToFP(RNE(), x_signed, Float32())
    >>> x_fp
    fpToFPUnsigned(RNE(), 4294967291)
    >>> simplify(x_fp)
    1*(2**32)
    """
    ...

def fpToFPUnsigned(rm, x, s, ctx=...):  # -> FPRef:
    """Create a Z3 floating-point conversion expression, from unsigned bit-vector to floating-point expression."""
    ...

def fpToSBV(rm, x, s, ctx=...):  # -> BitVecRef:
    """Create a Z3 floating-point conversion expression, from floating-point expression to signed bit-vector.

    >>> x = FP('x', FPSort(8, 24))
    >>> y = fpToSBV(RTZ(), x, BitVecSort(32))
    >>> print(is_fp(x))
    True
    >>> print(is_bv(y))
    True
    >>> print(is_fp(y))
    False
    >>> print(is_bv(x))
    False
    """
    ...

def fpToUBV(rm, x, s, ctx=...):  # -> BitVecRef:
    """Create a Z3 floating-point conversion expression, from floating-point expression to unsigned bit-vector.

    >>> x = FP('x', FPSort(8, 24))
    >>> y = fpToUBV(RTZ(), x, BitVecSort(32))
    >>> print(is_fp(x))
    True
    >>> print(is_bv(y))
    True
    >>> print(is_fp(y))
    False
    >>> print(is_bv(x))
    False
    """
    ...

def fpToReal(x, ctx=...):  # -> ArithRef:
    """Create a Z3 floating-point conversion expression, from floating-point expression to real.

    >>> x = FP('x', FPSort(8, 24))
    >>> y = fpToReal(x)
    >>> print(is_fp(x))
    True
    >>> print(is_real(y))
    True
    >>> print(is_fp(y))
    False
    >>> print(is_real(x))
    False
    """
    ...

def fpToIEEEBV(x, ctx=...):  # -> BitVecRef:
    """\brief Conversion of a floating-point term into a bit-vector term in IEEE 754-2008 format.

    The size of the resulting bit-vector is automatically determined.

    Note that IEEE 754-2008 allows multiple different representations of NaN. This conversion
    knows only one NaN and it will always produce the same bit-vector representation of
    that NaN.

    >>> x = FP('x', FPSort(8, 24))
    >>> y = fpToIEEEBV(x)
    >>> print(is_fp(x))
    True
    >>> print(is_bv(y))
    True
    >>> print(is_fp(y))
    False
    >>> print(is_bv(x))
    False
    """
    ...

class SeqSortRef(SortRef):
    """Sequence sort."""
    def is_string(self):  # -> Any:
        """Determine if sort is a string
        >>> s = StringSort()
        >>> s.is_string()
        True
        >>> s = SeqSort(IntSort())
        >>> s.is_string()
        False
        """
        ...

    def basis(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        ...

class CharSortRef(SortRef):
    """Character sort."""

    ...

def StringSort(ctx=...):  # -> SeqSortRef:
    """Create a string sort
    >>> s = StringSort()
    >>> print(s)
    String
    """
    ...

def CharSort(ctx=...):  # -> CharSortRef:
    """Create a character sort
    >>> ch = CharSort()
    >>> print(ch)
    Char
    """
    ...

def SeqSort(s):  # -> SeqSortRef:
    """Create a sequence sort over elements provided in the argument
    >>> s = SeqSort(IntSort())
    >>> s == Unit(IntVal(1)).sort()
    True
    """
    ...

class SeqRef(ExprRef):
    """Sequence expression."""
    def sort(self):  # -> SeqSortRef:
        ...
    def __add__(self, other):  # -> SeqRef | ReRef | BitVecRef:
        ...
    def __radd__(self, other):  # -> SeqRef | ReRef | BitVecRef:
        ...
    def __getitem__(
        self, i
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def at(self, i):  # -> SeqRef:
        ...
    def is_string(self):  # -> Any:
        ...
    def is_string_value(self):  # -> Any:
        ...
    def as_string(self):  # -> str | Any:
        """Return a string representation of sequence expression."""
        ...

    def __le__(self, other) -> bool: ...
    def __lt__(self, other) -> bool: ...
    def __ge__(self, other) -> bool: ...
    def __gt__(self, other) -> bool: ...

class CharRef(ExprRef):
    """Character expression."""
    def __le__(self, other) -> bool: ...
    def to_int(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def to_bv(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...
    def is_digit(
        self,
    ):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
        ...

def CharVal(
    ch, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def CharFromBv(
    bv,
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def CharToBv(
    ch, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def CharToInt(
    ch, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def CharIsDigit(
    ch, ctx=...
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def is_seq(a):  # -> bool:
    """Return `True` if `a` is a Z3 sequence expression.
    >>> print (is_seq(Unit(IntVal(0))))
    True
    >>> print (is_seq(StringVal("abc")))
    True
    """
    ...

def is_string(a):  # -> Any | Literal[False]:
    """Return `True` if `a` is a Z3 string expression.
    >>> print (is_string(StringVal("ab")))
    True
    """
    ...

def is_string_value(a):  # -> Any | Literal[False]:
    """return 'True' if 'a' is a Z3 string constant expression.
    >>> print (is_string_value(StringVal("a")))
    True
    >>> print (is_string_value(StringVal("a") + StringVal("b")))
    False
    """
    ...

def StringVal(s, ctx=...):  # -> SeqRef:
    """create a string expression"""
    ...

def String(name, ctx=...):  # -> SeqRef:
    """Return a string constant named `name`. If `ctx=None`, then the global context is used.

    >>> x = String('x')
    """
    ...

def Strings(names, ctx=...):  # -> list[SeqRef]:
    """Return a tuple of String constants."""
    ...

def SubString(s, offset, length):  # -> SeqRef | BitVecRef:
    """Extract substring or subsequence starting at offset"""
    ...

def SubSeq(s, offset, length):  # -> SeqRef | BitVecRef:
    """Extract substring or subsequence starting at offset"""
    ...

def Empty(s):  # -> SeqRef | ReRef:
    """Create the empty sequence of the given sort
    >>> e = Empty(StringSort())
    >>> e2 = StringVal("")
    >>> print(e.eq(e2))
    True
    >>> e3 = Empty(SeqSort(IntSort()))
    >>> print(e3)
    Empty(Seq(Int))
    >>> e4 = Empty(ReSort(SeqSort(IntSort())))
    >>> print(e4)
    Empty(ReSort(Seq(Int)))
    """
    ...

def Full(s):  # -> ReRef:
    """Create the regular expression that accepts the universal language
    >>> e = Full(ReSort(SeqSort(IntSort())))
    >>> print(e)
    Full(ReSort(Seq(Int)))
    >>> e1 = Full(ReSort(StringSort()))
    >>> print(e1)
    Full(ReSort(String))
    """
    ...

def Unit(a):  # -> SeqRef:
    """Create a singleton sequence"""
    ...

def PrefixOf(a, b):  # -> BoolRef:
    """Check if 'a' is a prefix of 'b'
    >>> s1 = PrefixOf("ab", "abc")
    >>> simplify(s1)
    True
    >>> s2 = PrefixOf("bc", "abc")
    >>> simplify(s2)
    False
    """
    ...

def SuffixOf(a, b):  # -> BoolRef:
    """Check if 'a' is a suffix of 'b'
    >>> s1 = SuffixOf("ab", "abc")
    >>> simplify(s1)
    False
    >>> s2 = SuffixOf("bc", "abc")
    >>> simplify(s2)
    True
    """
    ...

def Contains(a, b):  # -> BoolRef:
    """Check if 'a' contains 'b'
    >>> s1 = Contains("abc", "ab")
    >>> simplify(s1)
    True
    >>> s2 = Contains("abc", "bc")
    >>> simplify(s2)
    True
    >>> x, y, z = Strings('x y z')
    >>> s3 = Contains(Concat(x,y,z), y)
    >>> simplify(s3)
    True
    """
    ...

def Replace(s, src, dst):  # -> SeqRef:
    """Replace the first occurrence of 'src' by 'dst' in 's'
    >>> r = Replace("aaa", "a", "b")
    >>> simplify(r)
    "baa"
    """
    ...

def IndexOf(s, substr, offset=...):  # -> ArithRef:
    """Retrieve the index of substring within a string starting at a specified offset.
    >>> simplify(IndexOf("abcabc", "bc", 0))
    1
    >>> simplify(IndexOf("abcabc", "bc", 2))
    4
    """
    ...

def LastIndexOf(s, substr):  # -> ArithRef:
    """Retrieve the last index of substring within a string"""
    ...

def Length(s):  # -> ArithRef:
    """Obtain the length of a sequence 's'
    >>> l = Length(StringVal("abc"))
    >>> simplify(l)
    3
    """
    ...

def SeqMap(
    f, s
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Map function 'f' over sequence 's'"""
    ...

def SeqMapI(
    f, i, s
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    """Map function 'f' over sequence 's' at index 'i'"""
    ...

def SeqFoldLeft(
    f, a, s
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def SeqFoldLeftI(
    f, i, a, s
):  # -> PatternRef | QuantifierRef | BoolRef | IntNumRef | ArithRef | RatNumRef | AlgebraicNumRef | BitVecNumRef | BitVecRef | ArrayRef | DatatypeRef | FPNumRef | FPRef | FiniteDomainNumRef | FiniteDomainRef | FPRMRef | SeqRef | CharRef | ReRef | ExprRef:
    ...
def StrToInt(s):  # -> ArithRef:
    """Convert string expression to integer
    >>> a = StrToInt("1")
    >>> simplify(1 == a)
    True
    >>> b = StrToInt("2")
    >>> simplify(1 == b)
    False
    >>> c = StrToInt(IntToStr(2))
    >>> simplify(1 == c)
    False
    """
    ...

def IntToStr(s):  # -> SeqRef:
    """Convert integer expression to string"""
    ...

def StrToCode(s):  # -> ArithRef:
    """Convert a unit length string to integer code"""
    ...

def StrFromCode(c):  # -> SeqRef:
    """Convert code to a string"""
    ...

def Re(s, ctx=...):  # -> ReRef:
    """The regular expression that accepts sequence 's'
    >>> s1 = Re("ab")
    >>> s2 = Re(StringVal("ab"))
    >>> s3 = Re(Unit(BoolVal(True)))
    """
    ...

class ReSortRef(SortRef):
    """Regular expression sort."""
    def basis(
        self,
    ):  # -> BoolSortRef | ArithSortRef | BitVecSortRef | ArraySortRef | DatatypeSortRef | FiniteDomainSortRef | FPSortRef | FPRMSortRef | ReSortRef | SeqSortRef | CharSortRef | TypeVarRef | SortRef:
        ...

def ReSort(s):  # -> ReSortRef:
    ...

class ReRef(ExprRef):
    """Regular expressions."""
    def __add__(self, other):  # -> ReRef:
        ...

def is_re(s):  # -> bool:
    ...
def InRe(s, re):  # -> BoolRef:
    """Create regular expression membership test
    >>> re = Union(Re("a"),Re("b"))
    >>> print (simplify(InRe("a", re)))
    True
    >>> print (simplify(InRe("b", re)))
    True
    >>> print (simplify(InRe("c", re)))
    False
    """
    ...

def Union(*args):  # -> ReRef:
    """Create union of regular expressions.
    >>> re = Union(Re("a"), Re("b"), Re("c"))
    >>> print (simplify(InRe("d", re)))
    False
    """
    ...

def Intersect(*args):  # -> ReRef:
    """Create intersection of regular expressions.
    >>> re = Intersect(Re("a"), Re("b"), Re("c"))
    """
    ...

def Plus(re):  # -> ReRef:
    """Create the regular expression accepting one or more repetitions of argument.
    >>> re = Plus(Re("a"))
    >>> print(simplify(InRe("aa", re)))
    True
    >>> print(simplify(InRe("ab", re)))
    False
    >>> print(simplify(InRe("", re)))
    False
    """
    ...

def Option(re):  # -> ReRef:
    """Create the regular expression that optionally accepts the argument.
    >>> re = Option(Re("a"))
    >>> print(simplify(InRe("a", re)))
    True
    >>> print(simplify(InRe("", re)))
    True
    >>> print(simplify(InRe("aa", re)))
    False
    """
    ...

def Complement(re):  # -> ReRef:
    """Create the complement regular expression."""
    ...

def Star(re):  # -> ReRef:
    """Create the regular expression accepting zero or more repetitions of argument.
    >>> re = Star(Re("a"))
    >>> print(simplify(InRe("aa", re)))
    True
    >>> print(simplify(InRe("ab", re)))
    False
    >>> print(simplify(InRe("", re)))
    True
    """
    ...

def Loop(re, lo, hi=...):  # -> ReRef:
    """Create the regular expression accepting between a lower and upper bound repetitions
    >>> re = Loop(Re("a"), 1, 3)
    >>> print(simplify(InRe("aa", re)))
    True
    >>> print(simplify(InRe("aaaa", re)))
    False
    >>> print(simplify(InRe("", re)))
    False
    """
    ...

def Range(lo, hi, ctx=...):  # -> ReRef:
    """Create the range regular expression over two sequences of length 1
    >>> range = Range("a","z")
    >>> print(simplify(InRe("b", range)))
    True
    >>> print(simplify(InRe("bb", range)))
    False
    """
    ...

def Diff(a, b, ctx=...):  # -> ReRef:
    """Create the difference regular expression"""
    ...

def AllChar(regex_sort, ctx=...):  # -> ReRef:
    """Create a regular expression that accepts all single character strings"""
    ...

def PartialOrder(a, index):  # -> FuncDeclRef:
    ...
def LinearOrder(a, index):  # -> FuncDeclRef:
    ...
def TreeOrder(a, index):  # -> FuncDeclRef:
    ...
def PiecewiseLinearOrder(a, index):  # -> FuncDeclRef:
    ...
def TransitiveClosure(f):  # -> FuncDeclRef:
    """Given a binary relation R, such that the two arguments have the same sort
    create the transitive closure relation R+.
    The transitive closure R+ is a new relation.
    """
    ...

def to_Ast(ptr):  # -> Ast:
    ...
def to_ContextObj(ptr):  # -> ContextObj:
    ...
def to_AstVectorObj(ptr):  # -> AstVectorObj:
    ...

_my_hacky_class = ...

def on_clause_eh(ctx, p, n, dep, clause):  # -> None:
    ...

_on_clause_eh = ...

class OnClause:
    def __init__(self, s, on_clause) -> None: ...

class PropClosures:
    def __init__(self) -> None: ...
    def set_threaded(self):  # -> None:
        ...
    def get(self, ctx): ...
    def set(self, ctx, r):  # -> None:
        ...
    def insert(self, r):  # -> int:
        ...

_prop_closures = ...

def ensure_prop_closures():  # -> None:
    ...
def user_prop_push(ctx, cb):  # -> None:
    ...
def user_prop_pop(ctx, cb, num_scopes):  # -> None:
    ...
def user_prop_fresh(ctx, _new_ctx): ...
def user_prop_fixed(ctx, cb, id, value):  # -> None:
    ...
def user_prop_created(ctx, cb, id):  # -> None:
    ...
def user_prop_final(ctx, cb):  # -> None:
    ...
def user_prop_eq(ctx, cb, x, y):  # -> None:
    ...
def user_prop_diseq(ctx, cb, x, y):  # -> None:
    ...
def user_prop_decide(ctx, cb, t_ref, idx, phase):  # -> None:
    ...

_user_prop_push = ...
_user_prop_pop = ...
_user_prop_fresh = ...
_user_prop_fixed = ...
_user_prop_created = ...
_user_prop_final = ...
_user_prop_eq = ...
_user_prop_diseq = ...
_user_prop_decide = ...

def PropagateFunction(name, *sig):  # -> FuncDeclRef:
    """Create a function that gets tracked by user propagator.
    Every term headed by this function symbol is tracked.
    If a term is fixed and the fixed callback is registered a
    callback is invoked that the term headed by this function is fixed.
    """
    ...

class UserPropagateBase:
    def __init__(self, s, ctx=...) -> None: ...
    def __del__(self):  # -> None:
        ...
    def ctx(self): ...
    def ctx_ref(self): ...
    def add_fixed(self, fixed):  # -> None:
        ...
    def add_created(self, created):  # -> None:
        ...
    def add_final(self, final):  # -> None:
        ...
    def add_eq(self, eq):  # -> None:
        ...
    def add_diseq(self, diseq):  # -> None:
        ...
    def add_decide(self, decide):  # -> None:
        ...
    def push(self): ...
    def pop(self, num_scopes): ...
    def fresh(self, new_ctx): ...
    def add(self, e):  # -> None:
        ...
    def next_split(self, t, idx, phase):  # -> Any:
        ...
    def propagate(self, e, ids, eqs=...):  # -> Any:
        ...
    def conflict(self, deps=..., eqs=...):  # -> None:
        ...

solver = str
Z3SOLVER = Solver

def Eq(a: ExprRef, b: ExprRef) -> BoolRef: ...
def NEq(a: ExprRef, b: ExprRef) -> BoolRef: ...
def _py2expr(x: Any) -> ExprRef: ...
def is_recognizer(a: ExprRef) -> bool: ...
def is_constructor(a: ExprRef) -> bool: ...
def is_accessor(a: ExprRef) -> bool: ...
def is_power(a: ExprRef) -> bool: ...
def is_if(a: ExprRef) -> bool: ...
